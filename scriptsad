=head1 NAME

adminModule.pl - Read the dropbox in all the customer chambers, validate the user and user request and inputs, then perform the action.

=cut

use constant VERSION => '1.4';

use Getopt::Long qw(:config no_ignore_case posix_default);
use Pod::Usage;
use Cwd;
use Term::ANSIColor qw(:constants);
use File::Basename;
use File::stat;
use Fcntl qw/ :DEFAULT :flock :seek /;

=head1 SYNOPSYS

adminModule [-debug] [-verbose] [-test] [-chamber <chamber name>]

adminModule -help|-h

adminModule -man

adminModule -version|-v

=cut

# read command line arguments.
my %opt = ();
GetOptions(\%opt, 'debug',
                  'verbose',
                  'test',
                  'chamber=s',
                  'help|h!',
                  'man',
                  'version|v!')
  or pod2usage(-verbose => 0, -exitval => 1, -output => \*STDERR);

=head1 OPTIONS

=over 4

=item B<-help|-h>

Print a brief help message and exit.

=cut

# have we provided the '-h' switch ?
if(defined $opt{help}) {
	pod2usage(-verbose => 1, -exitval => 0);
}

=item B<-debug>

Print debug information to the log file.

=cut

# have we set the debug flag ?
my $debug = 1;
if(defined $opt{debug}) {
	$debug = 0;
} else {
	$debug = 1;
}

=item B<-test>

Print to the log file a summary of what would get executed without actually executing the commands.

=cut

# have we set the test flag ?
my $test = 1;
if(defined $opt{test}) {
	$test = 0;
} else {
	$test = 1;
}

=item B<-verbose>

Print messages to the console. 

=cut

# have we set the verbose flag ?
my $verbose = 1;
if(defined $opt{verbose}) {
	$verbose = 0;
} else {
	$verbose = 1;
}

=item B<-chamber>

Specify the chamber in which to run.  Default value is all.

=cut

# have we defined the chamber in which to run ?
# default = "all" => will run in all chambers where admin module has been configured.
my $chamber;
if(defined $opt{chamber}) {
	$chamber = $opt{chamber};
} else {
	$chamber = "all";
}

=item B<-man>

Print the manual page and exit.

=cut

if(defined $opt{man}) {
	pod2usage(-verbose => 2, -exitval => 0);
}

=item B<-version|-v>

Print the version number and exit.

=cut

if(defined $opt{version} || defined $opt{v}) {
	print 'adminModule.pl version ' . VERSION . "\n";
	exit 0;
}

=back

=cut

# global variable declaration.
my @chamberList;       # array containing list of chambers and path to dropBox separated by a ":".
my @jobFiles;          # array containing list of job files present in the dropBox.
my $userName;          # unix name of person executing this program.
my $httpUserName;      # unix name of person authenticated on web browser for executing this program.
my $functionName;      # name of the function to perform.
my $chamberName;       # name of the chamber we are currently processing.
my $permissions;       # permissions for *chmod* operation.
my $snapName;          # snapshot name.
my $snapSched;         # snapshot schedule.
my $toUID;             # unix name of target user for *chown* operation.
my $fromUID;           # unix name of source user for *chown* operation.
my $toGID;             # unix group name for *chgrp* operation.
my $recursive;         # recursive option.
my $userPath;          # path entered by the user.
my $path;              # actual path on the netApp filer.
my $server;            # kill: the host computer that you want to kill PID on.
my $pid;               # kill: the PID that you want to kill from a specified host.
my $resultFile;        # file name where the results of the operation are entered.
my $chPrefix;          # chamber prefix, e.g., ba, sj, sh, etc...
my $ypPassFile;        # NIS passwd file.
my $ypGroupFile;       # NIS group file.
my $ypHomeFile;        # NIS home file.
my $ypProjFile;        # NIS projects file.
my $ypAppsFile;        # NIS auto.apps file
my $ypProcessFile;     # NIS auto.process file
my $status;            # return value of functions.
my $nextflag;          # flag to go to the next job file in the dropBox.
my $nextchamberflag;	  # flag to go to the next chamber in the chamber list.
my $isCDNSengr = -1;   # flag to confirm that user is a cadence engineer.
my $isCustomer = -1;   # flag to confirm that user is a customer.
my $logFile = "/var/log/adminModule.log"; # log file name.
my $log;               # flag to write the log.
my $logbuf;            # buffer to contain the message to be written to the log file.
my $PIDFILE = "/tmp/adminModule.pid"; # pid file to ensure only one instance is running at any time.
my $mailBuf;           # buffer to store the email contents.

# get a lock on the pid.
&take_lock();

# open the log file for writing, else exit.
open(LOGFILE, ">>", $logFile)
	or die "Can't open file $logFile: $!\n";

# print the time-stamp on the log file everyday.
my ($mmWeekday, $mmMonth, $mmMonthday, $mmTime, @rst) = split(/\s+/, scalar localtime);
if ($mmTime eq "12:00:00") {
   printf(LOGFILE "*******************************************************************************\n");
   printf(LOGFILE "TIMESTAMP: %s\n", scalar localtime);
   printf(LOGFILE "*******************************************************************************\n\n");
}

# check if we're in "test" mode and print message to the log file.
if($test == 0) {
	print(LOGFILE "\n\n");
	printf(LOGFILE "*******************************************************************************\n");
	printf(LOGFILE "******************************RUNNING IN TEST MODE*****************************\n");
	printf(LOGFILE "*******************************************************************************\n");
	print(LOGFILE "\n\n");
}

# get the list of chambers at the site we are running.
# contains a list of chambers and path to the droBox separated by a colon, i.e., ":".
@chamberList = getChamberList($chamber);

# get the chamber prefix (ba, sj, sh, etc...)
$chPrefix = getSitePrefix();

# go through each chamber in the list.
foreach(@chamberList) {

	# split the line at ":" to get the chamber name and path to dropBox.
	my @buffer = split(":", $_);

	# get the chamber name.
	my $chName = $buffer[0];

	# get the path of the dropBox.
	my $chPath = $buffer[1];

	# get the chamber number.
	my $chNum = substr($chName, 2, 3);

	# set counter to zero.
	my $count = 0;

	#print "@buffer\n";
	#print "$chName\n";
	#print "$chPath\n";
	#print "$chNum\n";
	#print "$count\n";

	# set the job file name prefix.
	my $jobFilePrefix = $chPrefix . $chNum;

	# set the NIS passwd, group, home and projects file for the chamber.
	$ypPassFile = "/var/yp/src/"    . $chPrefix . $chNum . "/passwd";
	$ypGroupFile = "/var/yp/src/"   . $chPrefix . $chNum . "/group";
	$ypHomeFile = "/var/yp/src/"    . $chPrefix . $chNum . "/auto.home";
	$ypProjFile = "/var/yp/src/"    . $chPrefix . $chNum . "/auto.proj";
	$ypRscratchFile = "/var/yp/src/"    . $chPrefix . $chNum . "/auto.rscratch";
        $ypAppsFile = "/var/yp/src/"    . $chPrefix . $chNum . "/auto.apps";
        $ypProcessFile = "/var/yp/src/" . $chPrefix . $chNum . "/auto.process";

	# check if the dropBox exists else print a warning message and continue to next chamber.
	if(-d $chPath) {

		# get list of all job files in the dropBox.
		@jobFiles = <$chPath/$jobFilePrefix*>;

		# if no job files, then go to next chamber.
		if(!@jobFiles) {

			# write to the log file.
                        #shiqun: not write this info since the log file will be too huge.

			#$logbuf = "No job files !!!";
			#log = 0;
			#writeLog($log, $debug, $verbose, "red", $logbuf);

			# go to the next chamber.
			$nextchamberflag = 0;
			goto NEXTCHAMBER;
		} elsif(@jobFiles) {

			# continue to process the current chamber.
			$nextchamberflag = 1;

			# start processing each job file in the dropBox in current chamber.
			foreach my $file (@jobFiles) {
                                #initial the variable for every job file
                                ($userName, $httpUserName, $functionName, $chamberName, 
                                 $permissions, $snapName, $snapSched, $toUID, $fromUID, 
                                 $toGID, $recursive, $userPath, $server, $pid) =
                                    ("NULL", "NULL", "NULL", "NULL", 
                                     "NULL", "NULL", "NULL", "NULL", "NULL",
                                     "NULL", "NULL", "NULL", "NULL", "NULL");


				# write to the log file.
                                $logbuf = "TIMESTAMP: " . scalar(localtime) . "\n";
				$logbuf .= "Processing " . $file . "...";
				$log = 0;
				writeLog($log, $debug, $verbose, "blue", $logbuf);

				# open the job file.
				open(JOBFILE, "<", $file)
					or die "Can't open file $file: $!";

				# write to the log file.
				$logbuf = "Parsing jobfile " . $file . " for user inputs.";
				$log = 1;
				writeLog($log, $debug, $verbose, "blue", $logbuf);

                                #preproess the job file for HTTPNAME
                                foreach my $line (<JOBFILE>) {
                                   if ($line =~ /HTTPNAME/) {
                                      # read the user name.
                                      my @buffer = split(":", $line);
                                      $httpUserName = $buffer[1];
                                      $httpUserName =~ s/^\s+//;
                                      $httpUserName =~ s/\s+$//;
                                      chomp($httpUserName);
                                   }
                                }
 
                                seek(JOBFILE, 0, 0);

				# parse the job file.
				foreach my $line (<JOBFILE>) {

					# get the chamber name.
					if($line =~ /CHAMBER/) {

						# read chamber name.
						my @buffer = split(":", $line);
						$chamberName = $buffer[1];
						$chamberName =~ s/^\s+//;
						$chamberName =~ s/\s+$//;
						chomp($chamberName);

						# write to the log file.
						$logbuf = "Chamber Name: " . $chamberName . ".";
						$log = 1;
						writeLog($log, $debug, $verbose, "blue", $logbuf);

						$logbuf = "Validating chamber...";
						$log = 1;
						writeLog($log, $debug, $verbose, "blue", $logbuf);

						# validate chamber name.
						# chamber should not be <site prefix>00
						$status = validateChambers($chamberName);

						# chamber name not validated.
						# job file wants to execute an operation in chamber zero.
						if($status == 1) {

							# write to the log file.
							$logbuf = "ERROR !!! You cannot run this in Chamber Zero.";
							$log = 0;
							writeLog($log, $debug, $verbose, "red", $logbuf);
							
							# send email alert.
							#$mailBuf = $file . " attempting to run job in chamber zero !!!";
							#&mailVCAD($mailBuf);

							# invalidate the job file.
							$result = invalidateJob($file, $chPath);

							# job file invalidated.
							if($result == 0) {

								# write to the log file.
								$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to invalidate the job file.
							
								# send email alert.
								$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								&mailVCAD($mailBuf);

								# write to the log file.
								$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);
							}

							# go to next job file.
							$nextflag = 0;
                                                        $message = "Invalid chamber $chamberName";
							goto NEXT;
						} else {

							# chamber name validated.
							# process the current job file.
							$nextflag = 1;

							# write to the log file.
							$logbuf = "Chamber name " . $chamberName . " validated.";
							$log = 0;
							writeLog($log, $debug, $verbose, "blue", $logbuf);

							$logbuf = "Running in chamber " . $chamberName . ".";
							$log = 0;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						}
					}

					# get the user name of the person running the application.
					if($line =~ /USERNAME/) {

						# read the user name.
						my @buffer = split(":", $line);
						$userName = $buffer[1];
						$userName =~ s/^\s+//;
						$userName =~ s/\s+$//;
						chomp($userName);

						# write to the log file.
						$logbuf = "User name: " . $userName . ".";
						$log = 0;
						writeLog($log, $debug, $verbose, "blue", $logbuf);

                 
                 				if(($httpUserName ne "NULL") && (length($httpUserName)>0)) {	
                 
                 					# confirm that http user name has been passed through the browser.
                 					if($userName eq "cmlsadm") {
                 						$userName = $httpUserName;
                 
                 						# write to the log file.
                 						$logbuf = "Using web interface.  Changing userName to: " . $userName . ".";
                 						$log = 1;
                 						writeLog($log, $debug, $verbose, "blue", $logbuf);
                 
                 					} else {
                 
                 						# send email alert.
                 						#$mailBuf = "ERROR !!! It appears that the web interface has been used but httpUserName for $userName is in valid in job " . $file . "\.";
                 						#&mailVCAD($mailBuf);
                 
                 						# http user name not entered via browser.
                 						$logbuf = "ERROR !!! It appears that the web interface has been used but httpUserName is invalid !!!";
                 						$log = 1;
                 						writeLog($log, $debug, $verbose, "red", $logbuf);
                 
                 						# invalidate the job file.
                 						$result = invalidateJob($file, $chPath);
                 
                 						# job file invalidated.
                 						if($result == 0) {
                 
                 							# write to the log file.
                 							$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
                 							$log = 1;
                 							writeLog($log, $debug, $verbose, "blue", $logbuf);
                 						} else {
                 
                 							# unable to invalidate the job file.
                 							
                 							# send email alert.
                 							$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
                 							&mailVCAD($mailBuf);
                 
                 							# write to the log file.
                 							$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
                 							$log = 1;
                 							writeLog($log, $debug, $verbose, "red", $logbuf);
                 						}
                 
                 						# go to the next job file.
                 						$nextflag = 0;
                                                                $message = "invalid user name $userName";
                 						goto NEXT;
                 					}
                                               }
                                        }
                                        
                                        #HTTPNAME alread preprocessed.
                                        if ($line =~ /HTTPNAME/) {
                                           next;
                                        }

					# get the function to be performed.
					if($line =~ /FUNCTION/) {

						# read the function name.
						my @buffer = split(":", $line);
						$functionName = $buffer[1];
						$functionName =~ s/^\s+//;
						$functionName =~ s/\s+$//;
						chomp($functionName);

						if(($functionName eq "chown") 
							or ($functionName eq "chmod") 
							or ($functionName eq "chgrp") 
							or ($functionName eq "touch") 
							or ($functionName eq "du") 
							or ($functionName eq "kill") 
							or ($functionName eq "licmanage") 
							or ($functionName eq "snapshotListAndSchedule") 
							or ($functionName eq "snapshotEditSchedule") 
							or ($functionName eq "snapshotDelete")) {

								# write to the log file.
								$logbuf = "Function: " . $functionName . ".";
								$log = 0;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
						} else {

							# send email alert.
							#$mailBuf = "ERROR !!! " . $userName . " attempting to run unknown function " . $functionName . " via job " . $file . "\.";
							#&mailVCAD($mailBuf);

							# write to the log file.
							$logbuf = "ERROR !!! Invalid function name = " . $functionName . " !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

							# invalidate the job file.
							$result = invalidateJob($file, $chPath);

							# job file invalidated.
							if($result == 0) {

								# write to the log file.
								$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to invalidate the job file.
							
								# send email alert.
								$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								&mailVCAD($mailBuf);

								# write to the log file.
								$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);
							}

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "unsupported adminModule command $functionName";
							goto NEXT;
						}
					}

					# get the toUID.
					if($line =~ /toUID/) {

						# read the toUID.
						my @buffer = split(":", $line);
						$toUID = $buffer[1];
						$toUID =~ s/^\s+//;
						$toUID =~ s/\s+$//;
						chomp($toUID);

						# write to the log file.
						$logbuf = "toUID: " . $toUID . ".";
						$log = 0;
						writeLog($log, $debug, $verbose, "blue", $logbuf);
						$logbuf = "Validating toUID...";
						$log = 1;
						writeLog($log, $debug, $verbose, "blue", $logbuf);

						# check for special characters.
						$status = checkSpecialCharacters($toUID);

						# found special characters.
						if($status == 1) {

							# write to the log file.
							$logbuf = "ERROR !!! Username can't contain any special characters !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

							# invalidate the job file.
							$result = invalidateJob($file, $chPath);

							# job file invalidated.
							if($result == 0) {

								# write to the log file.
								$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to invalidate the job file.
							
								# send email alert.
								$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								&mailVCAD($mailBuf);

								# write to the log file.
								$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);
							}

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "invalid target user name $toUID";
							goto NEXT;
						}

						# validate the toUID.
						$status = validateUID($toUID);

						# toUID not validated.
						if($status == 1) {

							# send email alert.
							#$mailBuf = "ERROR !!! " . $userName . " attempting to access or modify files for user " . $toUID . " via job " . $file . "\.";
							#&mailVCAD($mailBuf);

							# write to the log file.
							$logbuf = "ERROR !!! Invalid user !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

							# invalidate the job file.
							$result = invalidateJob($file, $chPath);

							# job file invalidated.
							if($result == 0) {

								# write to the log file.
								$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to invalidate the job file.
							
								# send email alert.
								$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								&mailVCAD($mailBuf);

								# write to the log file.
								$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);
							}

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "invalid target user name $toUID";
							goto NEXT;
						} else {

							# toUID validated.
							# process the current job file.
							$nextflag = 1;

							# write to the log file.
							$logbuf = "toUID " . $toUID . " validated.";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						}
					}

					# get the fromUID.
					if($line =~ /fromUID/) {

						# read the fromUID.	
						my @buffer = split(":", $line);
						$fromUID = $buffer[1];
						$fromUID =~ s/^\s+//;
						$fromUID =~ s/\s+$//;
						chomp($fromUID);

						# write to the log file.
						$logbuf = "fromUID: " . $fromUID . ".";
						$log = 0;
						writeLog($log, $debug, $verbose, "blue", $logbuf);
						$logbuf = "Validating fromUID...";
						$log = 1;
						writeLog($log, $debug, $verbose, "blue", $logbuf);

						# check for special characters.
						$status = checkSpecialCharacters($fromUID);

						# found special characters.
						if($status == 1) {

							# write to the log file.
							$logbuf = "ERROR !!! Username can't contain any special characters !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

							# invalidate the job file.
							$result = invalidateJob($file, $chPath);

							# job file invalidated.
							if($result == 0) {

								# write to the log file.
								$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to invalidate the job file.
							
								# send email alert.
								$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								&mailVCAD($mailBuf);

								# write to the log file.
								$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);
							}

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "invalid source user name $fromUID";
							goto NEXT;
						}

						# validate the fromUID.
						$status = validateUID($fromUID);

						# fromUID not validated.
						if($status == 1) {

							# send email alert.
							#$mailBuf = "ERROR !!! " . $userName . " attempting to access or modify files for user " . $fromUID . " via job " . $file . "\.";
							#&mailVCAD($mailBuf);

							# write to the log file.
							$logbuf = "ERROR !!! Invalid user !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

							# invalidate the job file.
							$result = invalidateJob($file, $chPath);

							# job file invalidated.
							if($result == 0) {

								# write to the log file.
								$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to invalidate the job file.
							
								# send email alert.
								$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								&mailVCAD($mailBuf);

								# write to the log file.
								$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);
							}

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "invalud source user name $fromUID";
							goto NEXT;
						} else {

							# from UID validated.
							# process the current job file.
							$nextflag = 1;

							# write to the log file.
							$logbuf = "fromUID " . $fromUID . " validated.";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						}
					}

					# read the group name.
					if($line =~ /toGID/) {

						# read the toGID.
						my @buffer = split(":", $line);
						$toGID = $buffer[1];
						$toGID =~ s/^\s+//;
						$toGID =~ s/\s+$//;
						chomp($toGID);

						# write to the log file.
						$logbuf = "toGID: " . $toGID . ".";
						$log = 0;
						writeLog($log, $debug, $verbose, "blue", $logbuf);
						$logbuf = "Validating toGID...";
						$log = 1;
						writeLog($log, $debug, $verbose, "blue", $logbuf);

						# check for special characters.
						$status = checkSpecialCharacters($toGID);

						# found special characters in group name.
						if($status == 1) {

							# write to the log file.
							$logbuf = "ERROR !!! Group name can't contain any special characters !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

							# invalidate the job file.
							$result = invalidateJob($file, $chPath);

							# job file invalidated.
							if($result == 0) {

								# write to the log file.
								$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to invalidate the job file.
							
								# send email alert.
								$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								&mailVCAD($mailBuf);

								# write to the log file.
								$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);
							}

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "invalid target group name $toGID";
							goto NEXT;
						}

						# validate the toUID.
						$status = validateGID($toGID);

						# toGID not validated.
						if($status == 1) {

							# send email alert.
							#$mailBuf = "ERROR !!! " . $userName . " attempting to access group " . $toGID . " via job " . $file . "\.";
							#&mailVCAD($mailBuf);

							# write to the log file.
							$logbuf = "ERROR !!! Invalid group !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

							# invalidate the job file.
							$result = invalidateJob($file, $chPath);

							# job file invalidated.
							if($result == 0) {

								# write to the log file.
								$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to invalidate the job file.
							
								# send email alert.
								$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								&mailVCAD($mailBuf);

								# write to the log file.
								$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);
							}

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "invalid target group name $toGID";
							goto NEXT;
						} else {

							# toGID validated.
							# process the current job file.
							$nextflag = 1;

							# write to the log file.
							$logbuf = "toGID " . $toGID . " validated.";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						}
					}

					# get the recursive options.
					if($line =~ /RECURSIVE/) {

						# read the recursive option.
						my @buffer = split(":", $line);
						$recursive = $buffer[1];
						$recursive =~ s/^\s+//;
						$recursive =~ s/\s+$//;
						chomp($recursive);

						if($recursive == 0) {

							# write to the log file.
							$logbuf = "Recursive option is " . $recursive . ", i.e., TRUE.";
							$log = 0;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						} elsif($recursive == 1) {

							# write to the log file.
							$logbuf = "Recursive option is " . $recursive . ", i.e., FALSE.";
							$log = 0;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						} else {

							# send email alert.
							#$mailBuf = "ERROR !!! " . $userName . " provides an invalid recursive value " . $recursive . " in job " . $file . "\.";
							#&mailVCAD($mailBuf);

							# write to the log file.
							$logbuf = "ERROR !!! Invalid recursive value = " . $recursive . " !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

							# invalidate the job file.
							$result = invalidateJob($file, $chPath);

							# job file invalidated.
							if($result == 0) {

								# write to the log file.
								$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to invalidate the job file.
							
								# send email alert.
								$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								&mailVCAD($mailBuf);

								# write to the log file.
								$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);
							}

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "invalid recursive specification $recursive";
							goto NEXT;
						}
					}

					# get the path.
					if($line =~ /PATH/) {

						# read the path.
						my @buffer = split(":", $line);
						$userPath = $buffer[1];
						$userPath =~ s/^\s+//;
						$userPath =~ s/\s+$//;
						chomp($userPath);

						# write to the log file.
						$logbuf = "User has entered the following path: " . $userPath . ".";
						$log = 0;
						writeLog($log, $debug, $verbose, "blue", $logbuf);

						# check for special characters.
						$status = checkSpecialCharacters($userPath);

						# found special characters.
						if($status == 1) {

							# send email alert.
							#$mailBuf = "ERROR !!! " . $userName . " provided some special characters in path " . $userPath . " via job " . $file . "\.";
							#&mailVCAD($mailBuf);

							# write to the log file.
							$logbuf = "ERROR !!! Path name can't contain any special characters !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

							# invalidate the job file.
							$result = invalidateJob($file, $chPath);

							# job file invalidated.
							if($result == 0) {

								# write to the log file.
								$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to invalidate the job file.
							
								# send email alert.
								$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								&mailVCAD($mailBuf);

								# write to the log file.
								$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);
							}

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "path $userPath contains unsupported special character";
							goto NEXT;
						}

						# validate the path.
						$status = validatePath($userPath);

						# path not validated.
						if($status == 1) {

							# send email alert.
							#$mailBuf = "ERROR !!! " . $userName . " provided invalid path " . $userPath . " via job " . $file . "\.";
							#&mailVCAD($mailBuf);

							# write to the log file.
							$logbuf = "ERROR !!! Invalid path !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

							# invalidate the job file.
							$result = invalidateJob($file, $chPath);

							# job file invalidated.
							if($result == 0) {

								# write to the log file.
								$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to invalidate the job file.
							
								# send email alert.
								$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								&mailVCAD($mailBuf);

								# write to the log file.
								$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);
							}

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "invalid path $userPath";
							goto NEXT;
						} else {

							# path validated.
							# process the current job file.
							$nextflag = 1;

							# write to the log file.
							$logbuf = "Path \"" . $userPath . "\" validated.";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						}

                                                if($userPath =~ /^\/process\/hosted\/?/) {

                                                        #my @processBuf = split(/\//, $userPath);
                                                        #my $processName = $processBuf[3];
                                                        #chomp($processName);

                                                        # validate the process hosted volume in the chamber.
                                                        # process should exist in auto.process file for the chamber.
                                                        $status = validateProcessHosted();

                                                        # hosted volume doesn't exist in chamber.
                                                        if($status == 1) {

                                                                # send email alert.
                                                                #&mailVCAD($mailBuf);

                                                                # write to the log file.
                                                                $logbuf = "ERROR !!! /process/hosted does not exist in this chamber.";
                                                                $log = 0;
                                                                writeLog($log, $debug, $verbose, "red", $logbuf);

                                                                # invalidate the job file.
                                                                $result = invalidateJob($file, $chPath);

                                                                # job file invalidated.
                                                                if($result == 0) {

                                                                        # write to the log file.
                                                                        $logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
                                                                        $log = 1;
                                                                        writeLog($log, $debug, $verbose, "blue", $logbuf);
                                                                } else {

                                                                        # unable to invalidate the job file.

                                                                        # send email alert.
                                                                       $mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
                                                                        &mailVCAD($mailBuf);

                                                                        # write to the log file.
                                                                        $logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
                                                                        $log = 1;
                                                                        writeLog($log, $debug, $verbose, "red", $logbuf);
                                                                }

                                                                # go to next job file.
                                                                $nextflag = 0;
                                                                $message = "/process/hosted does not exist in the chamber";
                                                                goto NEXT;
                                                        } else {

                                                                # chamber name validated.
                                                                # process the current job file.
                                                                $nextflag = 1;

                                                                # write to the log file.
                                                                $logbuf = "/process/hosted volume validated.";
                                                                $log = 0;
                                                                writeLog($log, $debug, $verbose, "blue", $logbuf);
                                                        }
                                                }


                                                if($userPath =~ /^\/apps\/hosted\/?/) {

                                                        #my @appsBuf = split(/\//, $userPath);
                                                        #my $appsName = $appsBuf[3];
                                                        #chomp($appsName);

                                                        # validate the apps hosted volume in the chamber.
                                                        # project should exist in auto.apps file for the chamber.
                                                        $status = validateAppsHosted();

                                                        # hosted volume doesn't exist in chamber.
                                                        if($status == 1) {

                                                                # send email alert.
                                                                #&mailVCAD($mailBuf);

                                                                # write to the log file.
                                                                $logbuf = "ERROR !!! /apps/hosted does not exist in this chamber.";
                                                                $log = 0;
                                                                writeLog($log, $debug, $verbose, "red", $logbuf);

                                                                # invalidate the job file.
                                                                $result = invalidateJob($file, $chPath);

                                                                # job file invalidated.
                                                                if($result == 0) {

                                                                        # write to the log file.
                                                                        $logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
                                                                        $log = 1;
                                                                        writeLog($log, $debug, $verbose, "blue", $logbuf);
                                                                } else {

                                                                        # unable to invalidate the job file.

                                                                        # send email alert.
                                                                       $mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
                                                                        &mailVCAD($mailBuf);

                                                                        # write to the log file.
                                                                        $logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
                                                                        $log = 1;
                                                                        writeLog($log, $debug, $verbose, "red", $logbuf);
                                                                }

                                                                # go to next job file.
                                                                $nextflag = 0;
                                                                $message = "/apps/hosted does not exist in the chamber";
                                                                goto NEXT;
                                                        } else {

                                                                # chamber name validated.
                                                                # process the current job file.
                                                                $nextflag = 1;

                                                                # write to the log file.
                                                                $logbuf = "/apps/hosted volume validated.";
                                                                $log = 0;
                                                                writeLog($log, $debug, $verbose, "blue", $logbuf);
                                                        }
                                                }


						if($userPath =~ /^\/pro(j|jects?)\/?/) {
		
							my @projBuf = split(/\//, $userPath);
							my $projName = $projBuf[2];
							chomp($projName);

							# validate the project name.
							# project should exist in auto.proj file for the chamber.
							$status = validateProject($projName);

							# project name not validated.
							# project doesn't exist in chamber.
							if($status == 1) {

								# send email alert.
								#&mailVCAD($mailBuf);

								# write to the log file.
								$logbuf = "ERROR !!! Project " . $projName . " does not exist in this chamber.";
								$log = 0;
								writeLog($log, $debug, $verbose, "red", $logbuf);

								# invalidate the job file.
								$result = invalidateJob($file, $chPath);

								# job file invalidated.
								if($result == 0) {

									# write to the log file.
									$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
									$log = 1;
									writeLog($log, $debug, $verbose, "blue", $logbuf);
								} else {

									# unable to invalidate the job file.
							
									# send email alert.
									$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
									&mailVCAD($mailBuf);

									# write to the log file.
									$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
									$log = 1;
									writeLog($log, $debug, $verbose, "red", $logbuf);
								}

								# go to next job file.
								$nextflag = 0;
                                                                $message = "project $projName does not exist in the chamber";
								goto NEXT;
							} else {

								# chamber name validated.
								# process the current job file.
								$nextflag = 1;

								# write to the log file.
								$logbuf = "Project " . $projName . " validated.";
								$log = 0;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							}
						}

						if($userPath =~ /^\/rscratch\/?/) {
		
							my @projBuf = split(/\//, $userPath);
							my $projName = $projBuf[2];
							chomp($projName);

							# validate the project name.
							# project should exist in auto.proj file for the chamber.
							$status = validateRscratch($projName);

							# project name not validated.
							# project doesn't exist in chamber.
							if($status == 1) {

								# send email alert.
								#&mailVCAD($mailBuf);

								# write to the log file.
								$logbuf = "ERROR !!! Rscratch " . $projName . " does not exist in this chamber.";
								$log = 0;
								writeLog($log, $debug, $verbose, "red", $logbuf);

								# invalidate the job file.
								$result = invalidateJob($file, $chPath);

								# job file invalidated.
								if($result == 0) {

									# write to the log file.
									$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
									$log = 1;
									writeLog($log, $debug, $verbose, "blue", $logbuf);
								} else {

									# unable to invalidate the job file.
							
									# send email alert.
									$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
									&mailVCAD($mailBuf);

									# write to the log file.
									$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
									$log = 1;
									writeLog($log, $debug, $verbose, "red", $logbuf);
								}

								# go to next job file.
								$nextflag = 0;
                                                                $message = "rscratch $projName does not exist in the chamber";
								goto NEXT;
							} else {

								# chamber name validated.
								# process the current job file.
								$nextflag = 1;

								# write to the log file.
								$logbuf = "Rscratch " . $projName . " validated.";
								$log = 0;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							}
						}
					}

					# get the permissions.
					if($line =~ /PERMISSIONS/) {

						# read the permissions.
						my @buffer = split(":", $line);
						$permissions = $buffer[1];
						$permissions =~ s/^\s+//;
						$permissions =~ s/\s+$//;
						chomp($permissions);

						# write to the log file.
						$logbuf = "Permissions: " . $permissions . ".";
						$log = 1;
						writeLog($log, $debug, $verbose, "blue", $logbuf);

						$logbuf = "Validating permissions...";
						$log = 1;
						writeLog($log, $debug, $verbose, "blue", $logbuf);

						# check for special characters.
						$status = checkSpecialCharacters($permissions);

						# found special characters.
						if($status == 1) {

							# send email alert.
							#$mailBuf = "ERROR !!! The permission $userName provided contains special characters via job " . $file . "\.";
							#&mailVCAD($mailBuf);

							# write to the log file.
							$logbuf = "ERROR !!! Permissions can't contain any special characters !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

							# invalidate the job file.
							$result = invalidateJob($file, $chPath);

							# job file invalidated.
							if($result == 0) {

								# write to the log file.
								$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to invalidate the job file.
							
								# send email alert.
								$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								&mailVCAD($mailBuf);

								# write to the log file.
								$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);
							}

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "invalid permission specification $permissions";
							goto NEXT;
						}

						# validate the permissions.
						# valid values are 0, 1, 2, 3, 4
						$status = validatePermissions($permissions);

						# permissions not validated.
						if($status == 1) {

							# send email alert.
							#$mailBuf = "ERROR !!!  Ther permission $userName provided is invalid in job $file.";
							#&mailVCAD($mailBuf);

							# write to the log file.
							$logbuf = "ERROR !!! Invalid permissions !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

							# invalidate the job file.
							$result = invalidateJob($file, $chPath);

							# job file invalidated.
							if($result == 0) {

								# write to the log file.
								$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to invalidate the job file.
							
								# send email alert.
								$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								&mailVCAD($mailBuf);

								# write to the log file.
								$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);
							}

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "invalid permission specifiction $permissions";
							goto NEXT;
						} else {

							# permissions validated.
							# process the current job file.
							$nextflag = 1;

							# write to the log file.
							$logbuf = "Permissions validated.";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);

							# convert user options to unix permissions.
							# 0 => u=rX,g=rX,o=
							# 1 => u=rwX,g=rwX,o=
							# 2 => u=rwX,g=rX,o=
							# 3 => u=rwX,g=rX,o=rX
							# 4 => u=rwX,g=rwX,o=rX
							if($permissions == 0) {
								$permissions = "u=rX,g=rX,o="; 
								$logbuf = "\"chmod\"ing path to " . $permissions . " permissions.";
								$log = 0;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} elsif($permissions == 1) {
								$permissions = "u=rwX,g=rwX,o="; 
								$logbuf = "\"chmod\"ing path to " . $permissions . " permissions.";
								$log = 0;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} elsif($permissions == 2) {
								$permissions = "u=rwX,g=rX,o="; 
								$logbuf = "\"chmod\"ing path to " . $permissions . " permissions.";
								$log = 0;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} elsif($permissions == 3) {
                                                                $permissions = "u=rwX,g=rX,o=rX";
                                                                $logbuf = "\"chmod\"ing path to " . $permissions . " permissions.";
                                                                $log = 0;
                                                                writeLog($log, $debug, $verbose, "blue", $logbuf);
                                                        } elsif($permissions == 4) {
                                                                $permissions = "u=rwX,g=rwX,o=rX";
                                                                $logbuf = "\"chmod\"ing path to " . $permissions . " permissions.";
                                                                $log = 0;
                                                                writeLog($log, $debug, $verbose, "blue", $logbuf);
                                                        } 

						}
					}

					# get the snapshot name.
					if($line =~ /SNAP/) {

						# read the snapshot name.
						my @buffer = split(":", $line);
						$snapName = $buffer[1];
						$snapName =~ s/^\s+//;
						$snapName =~ s/\s+$//;
						chomp($snapName);

						# write to the log file.
						$logbuf = "Snapshot name: " . $snapName . ".";
						$log = 1;
						writeLog($log, $debug, $verbose, "blue", $logbuf);

						$logbuf = "Validating snapshot name...";
						$log = 1;
						writeLog($log, $debug, $verbose, "blue", $logbuf);

						# validate the snapshot name.
						$status = validateSnapName($snapName);

						# snapshot name not validated.
						if($status == 1) {

							# send email alert.
							#$mailBuf = "ERROR !!! " . $userName . " attempting to modify the non-existent snapshot " . $snapName . " via job " . $file . "\.";
							#&mailVCAD($mailBuf);

							# write to the log file.
							$logbuf = "ERROR !!! Invalid snapshot name !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

							# invalidate the job file.
							$result = invalidateJob($file, $chPath);

							# job file invalidated.
							if($result == 0) {

								# write to the log file.
								$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to invalidate the job file.
							
								# send email alert.
								$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								&mailVCAD($mailBuf);

								# write to the log file.
								$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);
							}

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "invalid snapshot name $snapName";
							goto NEXT;
						} else {

							# snapshot name validated.
							# process the current job file.
							$nextflag = 1;

							# write to the log file.
							$logbuf = "Snapshot name " . $snapName . " validated.";
							$log = 0;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						}
					}

					# get the snapshot schedule.
					if($line =~ /SCHED/) {

						# read the snapshot schedule.
						my @buffer = split(":", $line);
						$snapSched = $buffer[1];
						$snapSched =~ s/^\s+//;
						$snapSched =~ s/\s+$//;
						chomp($snapSched);

						# write to the log file.
						$logbuf = "Snapshot schedule: " . $snapSched . ".";
						$log = 1;
						writeLog($log, $debug, $verbose, "blue", $logbuf);

						$logbuf = "Validating snapshot schedule...";
						$log = 1;
						writeLog($log, $debug, $verbose, "blue", $logbuf);

						# validate the snapshot schedule.
						$status = validateSnapSchedule($snapSched);

						# snapshot schedule not validated.
						if($status == 1) {

							# send email alert.
							#$mailBuf = "ERROR !!! The snapshot schedule \"$snapSched\" $userName provided is invalid in job " . $file . "\.";
							#&mailVCAD($mailBuf);

							# write to the log file.
							$logbuf = "ERROR !!! Invalid snapshot schedule !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

							# invalidate the job file.
							$result = invalidateJob($file, $chPath);

							# job file invalidated.
							if($result == 0) {

								# write to the log file.
								$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to invalidate the job file.
							
								# send email alert.
								$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								&mailVCAD($mailBuf);

								# write to the log file.
								$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);
							}

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "invalid snapshot schedule \'$snapSched\'";
							goto NEXT;
						} else {

							# snapshot schedule validated.
							# process the current job file.
							$nextflag = 1;

							# write to the log file.
							$logbuf = "Snapshot schedule " . $snapSched . " validated.";
							$log = 0;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						}
					}
                                        #del with the kill/licmanage function, for SERVER name 
					if ($line =~ /SERVER/) {
						# read the server name.
						my @buffer = split(":", $line);
						$server = $buffer[1];
						$server =~ s/^\s+//;
						$server =~ s/\s+$//;
						chomp($server);

						# write to the log file.
						$logbuf = "server name: " . $server . ".";
						$log = 1;
						writeLog($log, $debug, $verbose, "blue", $logbuf);

						$logbuf = "get server name...";
                                                $staus = validateHost($chamberName, $server);

						if($status == 1) {

							# send email alert.
							#$mailBuf = "ERROR !!! $server is not a valid host in the chamber, you cannot kill job on that host\n";
							#&mailVCAD($mailBuf);

							# write to the log file.
							$logbuf = "ERROR !!! Invalid host name: $server !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

							# invalidate the job file.
							$result = invalidateJob($file, $chPath);

							# job file invalidated.
							if($result == 0) {

								# write to the log file.
								$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to invalidate the job file.
							
								# send email alert.
								$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								&mailVCAD($mailBuf);

								# write to the log file.
								$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);
							}

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "invalid host name $server in chamber $chamberName";
							goto NEXT;
						} else {

							# server validated.
							# process the current job file.
							$nextflag = 1;

							# write to the log file.
							$logbuf = "host $server validated.";
							$log = 0;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
                                                }
                                               
                                        }
                                        
                                        #del with the licmanage function, for license port  
					if ($line =~ /PORT/) {
						# read the license port in.
						my @buffer = split(":", $line);
						$port = $buffer[1];
						$port =~ s/^\s+//;
						$port =~ s/\s+$//;
						chomp($port);

						# write to the log file.
						$logbuf = "license port: $port";
						$log = 1;
						writeLog($log, $debug, $verbose, "blue", $logbuf);

						$logbuf = "get license port info...";
                                                $staus = validatePort($chamberName, $server, $port);

						if($status == 1) {

							# write to the log file.
							$logbuf = "ERROR !!! Invalid license port $port on $server !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

							# invalidate the job file.
							$result = invalidateJob($file, $chPath);

							# job file invalidated.
							if($result == 0) {

								# write to the log file.
								$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to invalidate the job file.
							
								# send email alert.
								$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								&mailVCAD($mailBuf);

								# write to the log file.
								$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);
							}

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "invalid license port $port on server $server";
							goto NEXT;
						} else {

							# server license port validated.
							# process the current job file.
							$nextflag = 1;

							# write to the log file.
							$logbuf = "license port $port validated.";
							$log = 0;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
                                                }
                                               
                                        }

                                        #del with the kill function, for PID
					if ($line =~ /PID/) {
						# read the PID name.
						my @buffer = split(":", $line);
						$pid = $buffer[1];
						$pid =~ s/^\s+//;
						$pid =~ s/\s+$//;
						chomp($pid);

						# write to the log file.
						$logbuf = "pid: $pid";
						$log = 1;
						writeLog($log, $debug, $verbose, "blue", $logbuf);

						$logbuf = "get pid information...";
                                                $staus = validatePID($server, $pid);

						if($status == 1) {

							# send email alert.
							#$mailBuf = "ERROR !!! process validation failed, you cannot kill job with pid $pid on host $server\n";
							#&mailVCAD($mailBuf);

							# write to the log file.
							$logbuf = "ERROR !!! Invalid pid $pid on $server !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

							# invalidate the job file.
							$result = invalidateJob($file, $chPath);

							# job file invalidated.
							if($result == 0) {

								# write to the log file.
								$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to invalidate the job file.
							
								# send email alert.
								$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								&mailVCAD($mailBuf);

								# write to the log file.
								$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);
							}

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "invalid PID $pid on server $server";
							goto NEXT;
						} else {

							# server validated.
							# process the current job file.
							$nextflag = 1;

							# write to the log file.
							$logbuf = "pid $pid validated.";
							$log = 0;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
                                                }
                                               
                                        }

				}

				# close the job file.
				close(JOBFILE);

				# write to the log file.
				$logbuf = "Validating user name...";
				$log = 1;
				writeLog($log, $debug, $verbose, "blue", $logbuf);

				# validate the user name.
				$status = validateUserName($userName, $chPath);
				# user name not validated.
				if($status == 1) {

					# send email alert.
					#$mailBuf = "ERROR !!! Unauthorized user " . $userName . " attempting to run the Admin Module via job " . $file . "\.";
					#&mailVCAD($mailBuf);

					# write to the log file.
					$logbuf = "ERROR !!! Unauthorized user !!!";
					$log = 1;
					writeLog($log, $debug, $verbose, "red", $logbuf);

					# invalidate the job file.
					$result = invalidateJob($file, $chPath);

					# job file invalidated.
					if($result == 0) {

						# write to the log file.
						$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
						$log = 1;
						writeLog($log, $debug, $verbose, "blue", $logbuf);
					} else {

						# unable to invalidate the job file.
					
						# send email alert.
						$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
						&mailVCAD($mailBuf);

						# write to the log file.
						$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
						$log = 1;
						writeLog($log, $debug, $verbose, "red", $logbuf);
					}

					# go to next job file.
					$nextflag = 0;
                                        $message = "Unauthorized user to run adminModule";
					goto NEXT;
				} else {

					# user name validated.
					# exists in dropBox/auth_users file as well as the NIS passwd file.
					# process the current job file.
					$nextflag = 1;

					# write to the log file.
					$logbuf = "Username " . $userName . " validated.";
					$log = 1;
					writeLog($log, $debug, $verbose, "blue", $logbuf);

					# write the user name in the log file.
					$logbuf = "User " . $userName . " has submitted this job.";
					$log = 0;
					writeLog($log, $debug, $verbose, "blue", $logbuf);

					# check if user is a cadence engineer.
					$isCDNSengr = checkUserType($userName);

					# user is a cadence engineer.
					if($isCDNSengr == 0) {

						# set flag isCustomer to false.
						$isCustomer = 1;
					} else {

						# user is a customer.
						# set flag isCustomer to true.
						$isCustomer = 0;
					}
				} 

				# get the results file.
				$resultFile = getResultFile($userName, $chamberName, $file);

				# write to the log file.
				$logbuf = "Result file: " . $resultFile . ".";
				$log = 1;
				writeLog($log, $debug, $verbose, "blue", $logbuf);

				# test mode = false			
				if( $test != 0) {	

					# open the result file.
					open(RESULT, '>', $resultFile) 
						or die "Unable to open file $resultFile: $!";
				}

                                #skip to validate NetAppPath for kill and licmanage
                                #since it has nothing to do with this.
                            
                                if (($functionName ne "kill") && ($functionName ne "licmanage")) {
				   # get the netApp path.	
				   # write to the log file.
				   $logbuf = "Getting netApp path for " . $userPath . ".";
				   $log = 1;
				   writeLog($log, $debug, $verbose, "blue", $logbuf);
				   #$path = getNetAppPath($userPath, $chamberName);
				   $path = getAccessPath($userPath, $chamberName);

				   # validate the netApp path.
				   $status = validateAccessPath($path);

				   # netApp path not validated.
				   if($status == 1) {

					# send email alert.
					#$mailBuf = "ERROR !!! The netApp path $userPath that $userName provided via job file $file is invalid.";
                                        #$mailBuf = "ERROR !!! the netApp path is invalid\r";
                                        #$mailBuf .= "path   :  $userPath\r";
                                        #$mailBuf .= "user   :  $userName\r";
                                        #$mailBuf .= "chamber:  $chamberName\r";
                                        #$mailBuf .= "job    :" . basename($file);
					#&mailVCAD($mailBuf);

					# write to the log file.
					$logbuf = "ERROR !!! Invalid netApp path !!!";
					$log = 1;
					writeLog($log, $debug, $verbose, "red", $logbuf);

					# invalidate the job file.
					$result = invalidateJob($file, $chPath);

					# job file invalidated.
					if($result == 0) {

						# write to the log file.
						$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
						$log = 1;
						writeLog($log, $debug, $verbose, "blue", $logbuf);
					} else {

						# unable to invalidate the job file.
							
						# send email alert.
						$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
						&mailVCAD($mailBuf);

						# write to the log file.
						$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
						$log = 1;
						writeLog($log, $debug, $verbose, "red", $logbuf);
					}

					# go to the next job file.
					$nextflag = 0;
                                        $message = "path $userPath is not valid\n";
					goto NEXT;
				   } else {

					# netApp path validated.
					# process the current job file.
					$nextflag = 1;

					# write to the log file.
					$logbuf = "netApp path " . $path . " validated.";
					$log = 1;
					writeLog($log, $debug, $verbose, "blue", $logbuf);
                                    }
                                }

				# chown operation.
				if($functionName eq "chown") {

					# customer job
					if($isCustomer == 0) {

						# if user provided path begins with /proj
						if($userPath =~ /^\/proj/ || $userPath =~ /^\/rscratch/) {
							$status = checkPROJmount($userPath);

							# provided mount path.
							if($status == 1) {
	
								# send email alert.
								#$mailBuf = "ERROR !!! " . $userName . " providing path " . $userPath . " for chown operation via job " . $file . "\.";
								#&mailVCAD($mailBuf);

								# write to the log file.
								$logbuf = "ERROR !!! Cannot provide mount path for chown operation !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);

								# invalidate the job file.
								$result = invalidateJob($file, $chPath);

								# job file invalidated.
								if($result == 0) {

									# write to the log file.
									$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
									$log = 1;
									writeLog($log, $debug, $verbose, "blue", $logbuf);
								} else {

									# unable to invalidate the job file.	
							
									# send email alert.
									$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
									&mailVCAD($mailBuf);

									# write to the log file.
									$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
									$log = 1;
									writeLog($log, $debug, $verbose, "red", $logbuf);
								}

								# go to the next job file.
								$nextflag = 0;
                                                                $message = "the path $userPath provided is a mount point which is not permitted.";
								goto NEXT;
							}
						}

                                                # /process/hosted, already checked 
                                                if($userPath =~ /^\/process\/hosted/) {
                                                }
                                                # /apps/hosted, already checked 
                                                if ($userPath =~ /^\/apps\/hosted/) {
                                                }

						# if user provided path begins with /home
						if($userPath =~ /^\/home/) {
							$status = checkCDNShome($userPath);
							if($status == 1) {

								# send email alert.
								#$mailBuf = "ERROR !!! " . $userName . " is attempting to modify a Cadence Engineers files by providing path " . $userPath . " for chown operation via job " . $file . "\.";
								#&mailVCAD($mailBuf);
								
								# write to the log file.
								$logbuf = "ERROR !!! Can't modify path of Cadence Engineers !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);

								# invalidate the job file.
								$result = invalidateJob($file, $chPath);

								# job file invalidated.
								if($result == 0) {

									# write to the log file.
									$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
									$log = 1;
									writeLog($log, $debug, $verbose, "blue", $logbuf);
								} else {

									# unable to invalidate the job file.
							
									# send email alert.
									$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
									&mailVCAD($mailBuf);

									# write to the log file.
									$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
									$log = 1;
									writeLog($log, $debug, $verbose, "red", $logbuf);
								}

								# go to the next job file.
								$nextflag = 0;
                                                                $message = "Customer users are not permitted to modify a Cadence Engineers files by providing path.";
								goto NEXT;
							}
						}

						# recursive
						if($recursive == 0) {

							# write to the log file.
							$logbuf = "Changing ownership of " . $path . " recursively to " . $toUID . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
							$status = do_chown($path, $recursive, $toUID);
						} elsif($recursive == 1 ) {	

							# non recursive.
							if($fromUID ne "NULL") {

								# write to the log file.
								$logbuf = "Changing ownership of " . $path . " from " . $fromUID . " to " . $toUID . ".";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);

								# fromUID is defined.
								$status = do_find_and_chown($path, $toUID, $fromUID);
							} else {

								# write to the log file.
								$logbuf = "Changing ownership of " . $path . " non-recursively to " . $toUID . ".";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);

								# fromUID is not defined.
								$status = do_chown($path, $recursive, $toUID);
							}
						}

						# test mode = false			
						#if( $test != 0) {	
						#	printf(RESULT "USER = %s\n", $userName);
						#	printf(RESULT "COMMAND = chown\n");
						#	printf(RESULT "PATH = $userPath\n");
						#	printf(RESULT "toUID = $toUID\n");
						#	printf(RESULT "RECURSIVE = $recursive\n");
						#	if(defined($fromUID)) {
						#		printf(RESULT "fromUID = $fromUID\n");
						#	}
						#}

						# operation successful.
						if($status == 0) {

							# archive the job file.
							$result = archiveJob($file, $chPath);

							# job file archived.
							if($result == 0) {

								# process the current job file.
								$nextflag = 1;

								# write to the log file.
								$logbuf = "Done processing.... Job file archived.";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to archive job file	
								# write to the log file.
								$logbuf = "ERROR !!! Unable to archive job file !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);

								# go to the next job file.
								$nextflag = 0;
                                                                $message = "SUCCESS, Unable to archive job file";
								goto NEXT;
							}

							# test mode = false	
							#if( $test != 0) {	
							#	printf(RESULT "Done !!!\n");
							#}

							# write to the log file.
							$logbuf = "Done processing.";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						} else {	

							# operation unsuccessful.
							# test mode = false
							#if( $test != 0) {	
							#	printf(RESULT "Error !!!\n");
							#}

							# send email alert.
							#$mailBuf = "ERROR !!! Unable to process job file $file. Reason: 0";
							#&mailVCAD($mailBuf);

							# write error message to log file.
							$logbuf = "ERROR !!! Unable to process job file " . $file . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

							# invalidate the job file.
							$result = invalidateJob($file, $chPath);

							# job file invalidated.
							if($result == 0) {

								# write to the log file.
								$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to invalidate the job file.
							
								# send email alert.
								$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								&mailVCAD($mailBuf);

								# write to the log file.
								$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);
							}

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "error executing chown command";
							goto NEXT;
						} 
					} else {

						# cadence engineer job
						# if user provided path begins with /proj
						if($userPath =~ /^\/proj/ || $userPath =~ /^\/rscratch/) {
							$status = checkPROJmount($userPath);

							# provided mount path.
							if($status == 1) {

								# send email alert.
								#$mailBuf = "ERROR !!! " . $userName . " providing path " . $userPath . " for chown operation via job " . $file . "\.";
								#&mailVCAD($mailBuf);

								# write to the log file.
								$logbuf = "ERROR !!! Cannot provide mount path for chown operation !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);

								# invalidate the job file.
								$result = invalidateJob($file, $chPath);

								# job file invalidated.
								if($result == 0) {

									# write to the log file.
									$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
									$log = 1;
									writeLog($log, $debug, $verbose, "blue", $logbuf);
								} else {

									# unable to invalidate the job file.	
							
									# send email alert.
									$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
									&mailVCAD($mailBuf);

									# write to the log file.
									$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
									$log = 1;
									writeLog($log, $debug, $verbose, "red", $logbuf);
								}

								# go to the next job file.
								$nextflag = 0;
                                                                $message = "mount path $userPath provided for chown operation which is not permitted.";
								goto NEXT;
							}
						}

                                                # /process/hosted, already checked
                                                if($userPath =~ /^\/process\/hosted/) {
                                                }
                                                # /apps/hosted, already checked
                                                if ($userPath =~ /^\/apps\/hosted/) {
                                                }


						# if user provided path begins with /home
						if($userPath =~ /^\/home/) {

							# send email alert.
							#$mailBuf = "ERROR !!! " . $userName . " attempting to modify /home... path " . $userPath . " for chown operation via job " . $file . "\.";
							#&mailVCAD($mailBuf);

							# provided mount path.
							# write to the log file.
							$logbuf = "ERROR !!! Can't modify paths starting from /home/... !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

							# invalidate the job file.
							$result = invalidateJob($file, $chPath);

							# job file invalidated.
							if($result == 0) {

								# write to the log file.
								$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to invalidate the job file.
							
								# send email alert.
								$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								&mailVCAD($mailBuf);

								# write to the log file.
								$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);
							}

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "Cadence engineers cannot modify paths starting from /home/...";
							goto NEXT;
						}

						# recursive
						if($recursive == 0) {

							# write to the log file.
							$logbuf = "Changing ownership of " . $path . " recursively to " . $toUID . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
							$status = do_chown($path, $recursive, $toUID);
						} elsif($recursive == 1 ) {	

							# non recursive.
							if($fromUID ne "NULL") {

								# write to the log file.
								$logbuf = "Changing ownership of " . $path . " from " . $fromUID . " to " . $toUID . ".";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);

								# fromUID is defined.
								$status = do_find_and_chown($path, $toUID, $fromUID);
							} else {

								# write to the log file.
								$logbuf = "Changing ownership of " . $path . " non-recursively to " . $toUID . ".";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);

								# fromUID is not defined.
								$status = do_chown($path, $recursive, $toUID);
							}
						}

						# test mode = false			
						#if( $test != 0) {	
						#	printf(RESULT "USER = %s\n", $userName);
						#	printf(RESULT "COMMAND = chown\n");
						#	printf(RESULT "PATH = $userPath\n");
						#	printf(RESULT "toUID = $toUID\n");
						#	printf(RESULT "RECURSIVE = $recursive\n");
						#	if(defined($fromUID)) {
						#		printf(RESULT "fromUID = $fromUID\n");
						#	}
						#}

						# operation successful.
						if($status == 0) {

							# archive the job file.
							$result = archiveJob($file, $chPath);

							# job file archived.
							if($result == 0) {

								# process the current job file.
								$nextflag = 1;

								# write to the log file.
								$logbuf = "Done processing... Archived job file " . $file . ".";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to archive job file	
								# write to the log file.
								$logbuf = "ERROR !!! Unable to archive job file !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);

								# go to the next job file.
								$nextflag = 0;
                                                                $message = "SUCCESS, Unable to archive job file";
								goto NEXT;
							}

							# test mode = false	
							#if( $test != 0) {	
							#	printf(RESULT "Done !!!\n");
							#}

							# write to the log file.
							$logbuf = "Done processing.";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						} else {	

							# operation unsuccessful.
							# test mode = false
							#if( $test != 0) {	
							#	printf(RESULT "Error !!!\n");
							#}

							# send email alert.
							#$mailBuf = "ERROR !!! Unable to process job file $file. Reason: 1";
							#&mailVCAD($mailBuf);

							# write error message to log file.
							$logbuf = "ERROR !!! Unable to process job file " . $file . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

							# invalidate the job file.
							$result = invalidateJob($file, $chPath);

							# job file invalidated.
							if($result == 0) {

								# write to the log file.
								$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to invalidate the job file.
							
								# send email alert.
								$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								&mailVCAD($mailBuf);

								# write to the log file.
								$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);
							}

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "error executing chown command";
							goto NEXT;
						}
					}
				}

				# chmod.
				if($functionName eq "chmod") {

					# customer job
					if($isCustomer == 0) {

						# if user provided path begins with /proj
						if($userPath =~ /^\/proj/ || $userPath =~ /^\/rscratch/) {
							$status = checkPROJmount($userPath);
							if($status == 1) {

								# send email alert.
								#$mailBuf = "ERROR !!! " . $userName . " providing path " . $userPath . " for chmod operation via job " . $file . "\.";
								#&mailVCAD($mailBuf);

								# provided mount path.
								# write to the log file.
								$logbuf = "ERROR !!! Cannot provide mount path for chmod operation !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);

								# invalidate the job file.
								$result = invalidateJob($file, $chPath);

								# job file invalidated.
								if($result == 0) {

									# write to the log file.
									$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
									$log = 1;
									writeLog($log, $debug, $verbose, "blue", $logbuf);
								} else {

									# unable to invalidate the job file.	
							
									# send email alert.
									$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
									&mailVCAD($mailBuf);

									# write to the log file.
									$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
									$log = 1;
									writeLog($log, $debug, $verbose, "red", $logbuf);
								}

								# go to the next job file.
								$nextflag = 0;
                                                                $message = "the path $userPath provided is a mount point which is not permitted.";
								goto NEXT;
							}
						}

                                                # /process/hosted, already checked
                                                if($userPath =~ /^\/process\/hosted/) {
                                                }
                                                # /apps/hosted, already checked
                                                if ($userPath =~ /^\/apps\/hosted/) {
                                                }



						# if user provided path begins with /home
						if($userPath =~ /^\/home/) {
							$status = checkCDNShome($userPath);
							if($status == 1) {

								# send email alert.
								#$mailBuf = "ERROR !!! " . $userName . " is attempting to modify a Cadence Engineers files by providing path " . $userPath . " for chmod operation via job " . $file . "\.";
								#&mailVCAD($mailBuf);
								
								# provided mount path.
								# write to the log file.
								$logbuf = "ERROR !!! Can't modify path of Cadence Engineers !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);

								# invalidate the job file.
								$result = invalidateJob($file, $chPath);

								# job file invalidated.
								if($result == 0) {

									# write to the log file.
									$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
									$log = 1;
									writeLog($log, $debug, $verbose, "blue", $logbuf);
								} else {

									# unable to invalidate the job file.	
							
									# send email alert.
									$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
									&mailVCAD($mailBuf);

									# write to the log file.
									$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
									$log = 1;
									writeLog($log, $debug, $verbose, "red", $logbuf);
								}


								# go to the next job file.
								$nextflag = 0;
                                                                $message = "Customer users are not permitted to modify a Cadence Engineers files by providing path.";
								goto NEXT;
							}
						}

						# recursive = true.
						if($recursive == 0) {
							$status = do_chmod($path, $recursive, $permissions);

							# verbose = true
							$logbuf = "Changed permissions of " . $path . " recursively to " . $permissions . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						} else {	

							# recursive = false.
							$status = do_chmod($path, $recursive, $permissions);

							# verbose = true
							$logbuf = "Changed permissions of " . $path . " non-recursively to " . $permissions . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						}

						# test mode = false
						#if( $test != 0) {	
						#	printf(RESULT "USER = %s\n", $userName);
						#	printf(RESULT "COMMAND = chmod\n");
						#	printf(RESULT "PATH = $userPath\n");
						#	printf(RESULT "PERMISSIONS = $permissions\n");
						#	printf(RESULT "RECURSIVE = $recursive\n");
						#}

						# operation successful.
						if($status == 0) {

							# archive the job file.
							$result = archiveJob($file, $chPath);

							# job file archived.
							if($result == 0) {

								# process the current job file.
								$nextflag = 1;

								# write to the log file.
								$logbuf = "Done processing.  Archived job file " . $file . ".";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to archive job file	
								# write to the log file.
								$logbuf = "ERROR !!! Unable to archive job file !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);

								# go to the next job file.
								$nextflag = 0;
                                                                $message = "SUCCESS, Unable to archive job file";
								goto NEXT;
							}

							# test mode = false
							#if( $test != 0) {	
							#	printf(RESULT "Done !!!\n");
							#}

							# write to the log file.
							$logbuf = "Done processing.  Archived job file " . $file . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						} else {	

							# operation unsuccessful.
							# test mode = false
							#if( $test != 0) {	
							#	printf(RESULT "Error !!!\n");
							#}

							# send email alert.
							#$mailBuf = "ERROR !!! Unable to process job file $file. Reason: 2";
							#&mailVCAD($mailBuf);

							# write error message to log file.
							$logbuf = "ERROR !!! Unable to process job file " . $file . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

							# invalidate the job file.
							$result = invalidateJob($file, $chPath);

							# job file invalidated.
							if($result == 0) {

								# write to the log file.
								$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to invalidate the job file.
							
								# send email alert.
								$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								&mailVCAD($mailBuf);

								# write to the log file.
								$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);
							}

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "error executing chmod";
							goto NEXT;
						} 
					} else {

						# cadence engineer job.
						# if user provided path begins with /proj
						if($userPath =~ /^\/proj/ || $userPath =~ /^\/rscratch/) {
							$status = checkPROJmount($userPath);
							if($status == 1) {

								# send email alert.
								#$mailBuf = "ERROR !!! " . $userName . " providing path " . $userPath . " for chmod operation via job " . $file . "\.";
								#&mailVCAD($mailBuf);

								# provided mount path.
								# write to the log file.
								$logbuf = "ERROR !!! Cannot provide mount path for chmod operation !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);

								# invalidate the job file.
								$result = invalidateJob($file, $chPath);

								# job file invalidated.
								if($result == 0) {

									# write to the log file.
									$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
									$log = 1;
									writeLog($log, $debug, $verbose, "blue", $logbuf);
								} else {

									# unable to invalidate the job file.	
							
									# send email alert.
									$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
									&mailVCAD($mailBuf);

									# write to the log file.
									$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
									$log = 1;
									writeLog($log, $debug, $verbose, "red", $logbuf);
								}

								# go to the next job file.
								$nextflag = 0;
                                                                $message = "the path $userPath is a mount point which is not permitted for chown.";
								goto NEXT;
							}
						}


                                                # /process/hosted, already checked
                                                if($userPath =~ /^\/process\/hosted/) {
                                                }
                                                # /apps/hosted, already checked
                                                if ($userPath =~ /^\/apps\/hosted/) {
                                                }


						# if user provided path begins with /home
						if($userPath =~ /^\/home/) {

							# send email alert.
							#$mailBuf = "ERROR !!! " . $userName . " attempting to modify /home... path " . $userPath . " for chmod operation via job " . $file . "\.";
							#&mailVCAD($mailBuf);

							# provided mount path.
							# write to the log file.
							$logbuf = "ERROR !!! Can't modify paths starting from /home/... !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

							# invalidate the job file.
							$result = invalidateJob($file, $chPath);

							# job file invalidated.
							if($result == 0) {

								# write to the log file.
								$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to invalidate the job file.	
							
								# send email alert.
								$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								&mailVCAD($mailBuf);

								# write to the log file.
								$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);
							}

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "Cadence engineers are not permitted to modify paths starting from /home/...";
							goto NEXT;
						}

						# recursive = true.
						if($recursive == 0) {
							$status = do_chmod($path, $recursive, $permissions);

							# verbose = true
							$logbuf = "Changed permissions of " . $path . " recursively to " . $permissions . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						} else {	

							# recursive = false.
							$status = do_chmod($path, $recursive, $permissions);

							$logbuf = "Changed permissions of " . $path . " non-recursively to " . $permissions . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						}

						# test mode = false
						#if( $test != 0) {	
						#	printf(RESULT "USER = %s\n", $userName);
						#	printf(RESULT "COMMAND = chmod\n");
						#	printf(RESULT "PATH = $userPath\n");
						#	printf(RESULT "PERMISSIONS = $permissions\n");
						#	printf(RESULT "RECURSIVE = $recursive\n");
						#}

						# operation successful.
						if($status == 0) {

							# archive the job file.
							$result = archiveJob($file, $chPath);

							# job file archived.
							if($result == 0) {

								# process the current job file.
								$nextflag = 1;

								# write to the log file.
								$logbuf = "Done processing.  Archived job file " . $file . ".";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to archive job file	
								# write to the log file.
							        $logbuf = "ERROR !!! Unable to archive job file !!!";
							        $log = 1;
						        	writeLog($log, $debug, $verbose, "red", $logbuf);

								# go to the next job file.
								$nextflag = 0;
                                                                $message = "SUCCESS, Unable to archive job file";
								goto NEXT;
							}

							# test mode = false
							#if( $test != 0) {	
							#	printf(RESULT "Done !!!\n");
							#}

							# write to the log file.
							$logbuf = "Done processing.  Archived job file " . $file . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						} else {	

							# operation unsuccessful.
							# test mode = false
							#if( $test != 0) {	
							#	printf(RESULT "Error !!!\n");
							#}

							# send email alert.
							#$mailBuf = "ERROR !!! Unable to process job file $file. Reason: 3";
							#&mailVCAD($mailBuf);

							# write error message to log file.
							$logbuf = "ERROR !!! Unable to process job file " . $file . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

							# invalidate the job file.
							$result = invalidateJob($file, $chPath);

							# job file invalidated.
							if($result == 0) {

								# write to the log file.
								$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to invalidate the job file.
							
								# send email alert.
								$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								&mailVCAD($mailBuf);

								# write to the log file.
								$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);
							}

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "error executing chmod";
							goto NEXT;
						}
					}
				}

				# chgrp.
				if($functionName eq "chgrp") {

					# customer job
					if($isCustomer == 0) {

						# if user provided path begins with /proj
						if($userPath =~ /^\/proj/ || $userPath =~ /^\/rscratch/) {
							$status = checkPROJmount($userPath);
							if($status == 1) {

								# send email alert.
								#$mailBuf = "ERROR !!! " . $userName . " providing path " . $userPath . " for chgrp operation via job " . $file . "\.";
								#&mailVCAD($mailBuf);

								# provided mount path.
								# write to the log file.
								$logbuf = "ERROR !!! Cannot provide mount path for chgrp operation !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);

								# invalidate the job file.
								$result = invalidateJob($file, $chPath);

								# job file invalidated.
								if($result == 0) {

									# write to the log file.
									$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
									$log = 1;
									writeLog($log, $debug, $verbose, "blue", $logbuf);
								} else {

									# unable to invalidate the job file.	
							
									# send email alert.
									$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
									&mailVCAD($mailBuf);

									# write to the log file.
									$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
									$log = 1;
									writeLog($log, $debug, $verbose, "red", $logbuf);
								}


								# go to the next job file.
								$nextflag = 0;
                                                                $message = "the path $userPath is a mount point which is not permitted for chgrp.";
								goto NEXT;
							}
						}

                                                # /process/hosted, already checked
                                                if($userPath =~ /^\/process\/hosted/) {
                                                }
                                                # /apps/hosted, already checked
                                                if ($userPath =~ /^\/apps\/hosted/) {
                                                }

						# if user provided path begins with /home
						if($userPath =~ /^\/home/) {
							$status = checkCDNShome($userPath);
							if($status == 1) {

								# send email alert.
								#$mailBuf = "ERROR !!! " . $userName . " is attempting to modify a Cadence Engineers files by providing path " . $userPath . " for chgrp operation via job " . $file . "\.";
								#&mailVCAD($mailBuf);
								
								# provided mount path.
								# write to the log file.
								$logbuf = "ERROR !!! Can't modify path of Cadence Engineers !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);

								# invalidate the job file.
								$result = invalidateJob($file, $chPath);

								# job file invalidated.
								if($result == 0) {

									# write to the log file.
									$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
									$log = 1;
									writeLog($log, $debug, $verbose, "blue", $logbuf);
								} else {

									# unable to invalidate the job file.	
							
									# send email alert.
									$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
									&mailVCAD($mailBuf);

									# write to the log file.
									$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
									$log = 1;
									writeLog($log, $debug, $verbose, "red", $logbuf);
								}

								# go to the next job file.
								$nextflag = 0;
                                                                $message = "Customer users are not permitted to modify a Cadence Engineers files by providing path";
								goto NEXT;
							}
						}

						# recursive
						if($recursive == 0) {
							$status = do_chgrp($path, $recursive, $toGID);

							# write to the log file.
							$logbuf = "Changed group membership of " . $path . " recursively to " . $toGID . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						} else {	

							#recursive = false.
							$status = do_chgrp($path, $recursive, $toGID);

							# write to the log file.
							$logbuf = "Changed group membership of " . $path . " non-recursively to " . $toGID . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						}

						# test mode = false
						#if( $test != 0) {	
						#	printf(RESULT "USER = %s\n", $userName);
						#	printf(RESULT "COMMAND = chgrp\n");
						#	printf(RESULT "PATH = $userPath\n");
						#	printf(RESULT "toGID = $toGID\n");
						#	printf(RESULT "RECURSIVE = $recursive\n");
						##}

						# operation successful.
						if($status == 0) {

							# archive the job file.
							$result = archiveJob($file, $chPath);

							# job file archived.
							if($result == 0) {

								# process the current job file.
								$nextflag = 1;

								# write to the log file.
								$logbuf = "Done processing.  Archived job file " . $file . ".";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to archive job file	
								# write to the log file.
					         		$logbuf = "ERROR !!! Unable to archive job file !!!";
						         	$log = 1;
						         	writeLog($log, $debug, $verbose, "red", $logbuf);

				         		         # go to the next job file.
						         	$nextflag = 0;
                                                                $message = "SUCCESS, Unable to archive job file";
						         	goto NEXT;
							}

							# test mode = false
							#if( $test != 0) {	
							#	printf(RESULT "Done !!!\n");
							#}

							# write to the log file.
							$logbuf = "Done processing.  Archived job file " . $file . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						} else {	

							# operation unsuccessful.
							# test mode = false
							#if( $test != 0) {	
							#	printf(RESULT "Error !!!\n");
							#}

							# send email alert.
							#$mailBuf = "ERROR !!! Unable to process job file $file. Reason: 4";
							#&mailVCAD($mailBuf);

							# write error message to log file.
							$logbuf = "ERROR !!! Unable to process job file " . $file . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

							# invalidate the job file.
							$result = invalidateJob($file, $chPath);

							# job file invalidated.
							if($result == 0) {

								# write to the log file.
								$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to invalidate the job file.
							
								# send email alert.
								$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								&mailVCAD($mailBuf);

								# write to the log file.
								$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);
							}

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "error executing chgrp";
							goto NEXT;
						}
					} else {

						# cadence engineer job.
						# if user provided path begins with /proj
						if($userPath =~ /^\/proj/ || $userPath =~ /^\/rscratch/) {
							$status = checkPROJmount($userPath);
							if($status == 1) {

								# send email alert.
								#$mailBuf = "ERROR !!! " . $userName . " providing path " . $userPath . " for chgrp operation via job " . $file . "\.";
								#&mailVCAD($mailBuf);

								# provided mount path.
								# write to the log file.
								$logbuf = "ERROR !!! Cannot provide mount path for chgrp operation !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);

								# invalidate the job file.
								$result = invalidateJob($file, $chPath);

								# job file invalidated.
								if($result == 0) {

									# write to the log file.
									$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
									$log = 1;
									writeLog($log, $debug, $verbose, "blue", $logbuf);
								} else {

									# unable to invalidate the job file.	
							
									# send email alert.
									$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
									&mailVCAD($mailBuf);

									# write to the log file.
									$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
									$log = 1;
									writeLog($log, $debug, $verbose, "red", $logbuf);
								}


								# go to the next job file.
								$nextflag = 0;
                                                                $message = "the path $userPath is a mount point which is not permitted for chgrp.";
								goto NEXT;
							}
						}


                                                # /process/hosted, already checked
                                                if($userPath =~ /^\/process\/hosted/) {
                                                }
                                                # /apps/hosted, already checked
                                                if ($userPath =~ /^\/apps\/hosted/) {
                                                }


						# if user provided path begins with /home
						if($userPath =~ /^\/home/) {

							# send email alert.
							#$mailBuf = "ERROR !!! " . $userName . " attempting to modify /home... path " . $userPath . " for chgrp operation via job " . $file . "\.";
							#&mailVCAD($mailBuf);

							# write to the log file.
							$logbuf = "ERROR !!! Can't modify paths starting from /home/... !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

							# invalidate the job file.
							$result = invalidateJob($file, $chPath);

							# job file invalidated.
							if($result == 0) {

								# write to the log file.
								$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to invalidate the job file.	
							
								# send email alert.
								$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								&mailVCAD($mailBuf);

								# write to the log file.
								$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);
							}

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "Cadence engineers are not permitted to modify paths starting from /home/...";
							goto NEXT;
						}

						# recursive
						if($recursive == 0) {
							$status = do_chgrp($path, $recursive, $toGID);

							# write to the log file.
							$logbuf = "Changed group membership of " . $path . " recursively to " . $toGID . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						} else {	#recursive = false.
							$status = do_chgrp($path, $recursive, $toGID);

							# write to the log file.
							$logbuf = "Changed group membership of " . $path . " non-recursively to " . $toGID . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						}

						# test mode = false
						#if( $test != 0) {	
						#	printf(RESULT "USER = %s\n", $userName);
						#	printf(RESULT "COMMAND = chgrp\n");
						#	printf(RESULT "PATH = $userPath\n");
						#	printf(RESULT "toGID = $toGID\n");
						#	printf(RESULT "RECURSIVE = $recursive\n");
						#}

						# operation successful.
						if($status == 0) {

							# archive the job file.
							$result = archiveJob($file, $chPath);

							# job file archived.
							if($result == 0) {

								# process the current job file.
								$nextflag = 1;

								# write to the log file.
								$logbuf = "Done processing.  Archived job file " . $file . ".";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to archive job file	
								# write to the log file.
								$logbuf = "ERROR !!! Unable to archive job file !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);

								# go to the next job file.
								$nextflag = 0;
                                                                $message = "SUCCESS, Unable to archive job file";
								goto NEXT;
							}

							# test mode = false
							#if( $test != 0) {	
							#	printf(RESULT "Done !!!\n");
							#}

							# write to the log file.
							$logbuf = "Done processing.  Archived job file " . $file . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						} else {	

							# operation unsuccessful.
							# test mode = false
							#if( $test != 0) {	
							#	printf(RESULT "Error !!!\n");
							#}

							# send email alert.
							#$mailBuf = "ERROR !!! Unable to process job file $file. Reason: 5";
							#&mailVCAD($mailBuf);

							# write error message to log file.
							$logbuf = "ERROR !!! Unable to process job file " . $file . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

							# invalidate the job file.
							$result = invalidateJob($file, $chPath);

							# job file invalidated.
							if($result == 0) {

								# write to the log file.
								$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
								$log = 1;
								writeLog($log, $debug, $verbose, "blue", $logbuf);
							} else {

								# unable to invalidate the job file.
							
								# send email alert.
								$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								&mailVCAD($mailBuf);

								# write to the log file.
								$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
								$log = 1;
								writeLog($log, $debug, $verbose, "red", $logbuf);
							}

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "error executing chgrp";
							goto NEXT;


						} 
					}
				}

				# touch.
				if($functionName eq "touch") {

					$status = do_touch($path);

					# test mode = false
					#if( $test != 0) {	
					#	printf(RESULT "USER = %s\n", $userName);
					#	printf(RESULT "COMMAND = touch\n");
					#	printf(RESULT "PATH = $userPath\n");
					#}

					# operation successful.
					if($status == 0) {

						# archive the job file.
						$result = archiveJob($file, $chPath);

						# job file archived.
						if($result == 0) {

							# process the current job file.
							$nextflag = 1;

							# write to the log file.
							$logbuf = "Done processing.  Archived job file " . $file . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						} else {

							# unable to archive job file	
							# write to the log file.
							$logbuf = "ERROR !!! Unable to archive job file !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "SUCCESS, Unable to archive job file";
							goto NEXT;
						}

						# test mode = false
						#if( $test != 0) {	
						#	printf(RESULT "Done !!!\n");
						#}

						# write to the log file.
						$logbuf = "Done processing.  Archived job file " . $file . ".";
						$log = 1;
						writeLog($log, $debug, $verbose, "blue", $logbuf);
					} else {	

						# operation unsuccessful.
						# test mode = false
						#if( $test != 0) {	
						#	printf(RESULT "Error !!!\n");
						#}

							# send email alert.
							#$mailBuf = "ERROR !!! Unable to process job file $file. Reason: 6";
							#&mailVCAD($mailBuf);

						# write error message to log file.
							$logbuf = "ERROR !!! Unable to process job file " . $file . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

						# invalidate the job file.
						$result = invalidateJob($file, $chPath);

						# job file invalidated.
						if($result == 0) {

							# write to the log file.
							$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						} else {

							# unable to invalidate the job file.
							
							# send email alert.
							$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
							&mailVCAD($mailBuf);

							# write to the log file.
							$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);
						}

						# go to the next job file.
						$nextflag = 0;
                                                $message = "error executing touch";
						goto NEXT;
					}
				}

				# du.
				if($functionName eq "du") {

					$status = do_du($path);

					# test mode = false
					#if( $test != 0) {	
					#	printf(RESULT "USER = %s\n", $userName);
					#	printf(RESULT "COMMAND = du\n");
					#	printf(RESULT "PATH = $userPath\n");
					#}

					# operation failed.
					if($status == -1) {

						# operation unsuccessful.
						# test mode = false
						#if( $test != 0) {	
						#	printf(RESULT "Error !!!\n");
						#}

							# send email alert.
							#$mailBuf = "ERROR !!! Unable to process job file $file. Reason: 7";
							#&mailVCAD($mailBuf);

						# write error message to log file.
							$logbuf = "ERROR !!! Unable to process job file " . $file . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

						# invalidate the job file.
						$result = invalidateJob($file, $chPath);

						# job file invalidated.
						if($result == 0) {

							# write to the log file.
							$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						} else {

							# unable to invalidate the job file.
							
							# send email alert.
							$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
							&mailVCAD($mailBuf);

							# write to the log file.
							$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);
						}

						# go to the next job file.
						$nextflag = 0;
                                                $message = "error executing du";
						goto NEXT;
					} else {	

						# operation successful.
						# archive the job file.
						$result = archiveJob($file, $chPath);

						# job file archived.
						if($result == 0) {

							# process the current job file.
							$nextflag = 1;

							# write to the log file.
							$logbuf = "Done processing.  Archived job file " . $file . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						} else {

							# unable to archive job file	
							# write to the log file.
							$logbuf = "ERROR !!! Unable to archive job file !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "SUCCESS, Unable to archive job file";
							goto NEXT;
						}

						# test mode = false
						#if( $test != 0) {	
						#	printf(RESULT "OUPUT = \n\n");
						#	printf(RESULT "%s\n\n", $status);
						#	printf(RESULT "Done !!!\n");
						#}
                                                $message = "SUCCESS, OUTPUT = \n\n";
                                                $message .= "$status\n\n"; 

						# write to the log file.
							$logbuf = "Done processing.  Archived job file " . $file . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
					}
				}
				# kill.
				if($functionName eq "kill") {

					$status = do_kill($server, $pid);

					# test mode = false
					#if( $test != 0) {	
					#	printf(RESULT "USER = %s\n", $userName);
					#	printf(RESULT "COMMAND = kill\n");
					#	printf(RESULT "SERVER = $server\n");
					#	printf(RESULT "PID = $pid\n");
					#}

					# operation failed.
					if($status != 0) {

						# operation unsuccessful.
						# test mode = false
						#if( $test != 0) {	
						#	printf(RESULT "Error !!!\n");
						#}

						# send email alert.
						#$mailBuf = "ERROR !!! Unable to process job file $file. Reason: 8";
						#&mailVCAD($mailBuf);

						# write error message to log file.
							$logbuf = "ERROR !!! Unable to process job file " . $file . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

						# invalidate the job file.
						$result = invalidateJob($file, $chPath);

						# job file invalidated.
						if($result == 0) {

							# write to the log file.
							$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						} else {

							# unable to invalidate the job file.
							
							# send email alert.
							$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
							&mailVCAD($mailBuf);

							# write to the log file.
							$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);
						}

						# go to the next job file.
						$nextflag = 0;
                                                $message = "error executing kill, pid is not correct?";
						goto NEXT;
					} else {	

						# operation successful.
						# archive the job file.
						$result = archiveJob($file, $chPath);

						# job file archived.
						if($result == 0) {

							# process the current job file.
							$nextflag = 1;

							# write to the log file.
							$logbuf = "Done processing.  Archived job file " . $file . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						} else {

							# unable to archive job file	
							# write to the log file.
							$logbuf = "ERROR !!! Unable to archive job file !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "SUCCESS, Unable to archive job file";
							goto NEXT;
						}

						# test mode = false
						#if( $test != 0) {	
						#	printf(RESULT "OUPUT = \n\n");
						#	printf(RESULT "%s\n\n", $status);
						#	printf(RESULT "Done !!!\n");
						#}

						# write to the log file.
							$logbuf = "Done processing.  Archived job file " . $file . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
					}
				}

				# licmanage.
				if($functionName eq "licmanage") {

					$status = do_licmanage($server, $port);

					# test mode = false
					#if( $test != 0) {	
					#	printf(RESULT "USER = %s\n", $userName);
					#	printf(RESULT "COMMAND = licmanage\n");
					#	printf(RESULT "SERVER = $server\n");
					#	printf(RESULT "PORT = $port\n");
					#}

					# operation failed.
					if($status != 0) {

						# operation unsuccessful.
						# test mode = false
						#if( $test != 0) {	
						#	printf(RESULT "Error !!!\n");
						#}

						# send email alert.
						#$mailBuf = "ERROR !!! Unable to process job file $file. Reason: 8";
						#&mailVCAD($mailBuf);

						# write error message to log file.
							$logbuf = "ERROR !!! Unable to process job file " . $file . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

						# invalidate the job file.
						$result = invalidateJob($file, $chPath);

						# job file invalidated.
						if($result == 0) {

							# write to the log file.
							$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						} else {

							# unable to invalidate the job file.
							
							# send email alert.
							$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
							&mailVCAD($mailBuf);

							# write to the log file.
							$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);
						}

						# go to the next job file.
						$nextflag = 0;
                                                $message = "Failed to start/restart license server on port $port";
						goto NEXT;
					} else {	

						# operation successful.
						# archive the job file.
						$result = archiveJob($file, $chPath);

						# job file archived.
						if($result == 0) {

							# process the current job file.
							$nextflag = 1;

							# write to the log file.
							$logbuf = "Done processing.  Archived job file " . $file . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						} else {

							# unable to archive job file	
							# write to the log file.
							$logbuf = "ERROR !!! Unable to archive job file !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "SUCCESS, Unable to archive job file";
							goto NEXT;
						}

						# test mode = false
						#if( $test != 0) {	
						#	printf(RESULT "OUPUT = \n\n");
						#	printf(RESULT "%s\n\n", $status);
						#	printf(RESULT "Done !!!\n");
						#}

						# write to the log file.
							$logbuf = "Done processing.  Archived job file " . $file . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
					}
                                }

				# snapshot list.
				if($functionName eq "snapshotListAndSchedule") {

					$status = do_snapshotListAndShow($path);

					# test mode = false
					#if( $test != 0) {	
					#	printf(RESULT "USER = %s\n", $userName);
					#	printf(RESULT "COMMAND = snapshotListAndSchedule\n");
					#	printf(RESULT "PATH = $userPath\n");
					#}

					# operation failed.
					if($status == -1) {

						# operation unsuccessful.
						# test mode = false
						#if( $test != 0) {	
						#	printf(RESULT "Error !!!\n");
						#}

						# send email alert.
						#$mailBuf = "ERROR !!! Unable to process job file $file. Reason: 9";
						#&mailVCAD($mailBuf);

						# write error message to log file.
						$logbuf = "ERROR !!! Unable to process job file " . $file . ".";
						$log = 1;
						writeLog($log, $debug, $verbose, "red", $logbuf);

						# invalidate the job file.
						$result = invalidateJob($file, $chPath);

						# job file invalidated.
						if($result == 0) {

							# write to the log file.
							$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						} else {

							# unable to invalidate the job file.
							
							# send email alert.
							$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
							&mailVCAD($mailBuf);

							# write to the log file.
							$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);
						}

						# go to the next job file.
						$nextflag = 0;
                                                $message = "error executing snapshotListAndSchedule";
						goto NEXT;
					} else {	

						# operation successful.
						# archive the job file.
						$result = archiveJob($file, $chPath);

						# job file archived.
						if($result == 0) {

							# process the current job file.
							$nextflag = 1;

							# write to the log file.
							$logbuf = "Done processing.  Archived job file " . $file . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						} else {

							# unable to archive job file	
							# write to the log file.
							$logbuf = "ERROR !!! Unable to archive job file !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "SUCCESS, Unable to archive job file";
							goto NEXT;
						}

						# test mode = false
						#if( $test != 0) {	
						#	printf(RESULT "OUPUT = \n\n");
						#	printf(RESULT "%s\n\n", $status);
						#	printf(RESULT "Done !!!\n");
						#}
                                                $message = "SUCCESS, OUTPUT = \n\n";
                                                $message .= "$status\n\n";

						# write to the log file.
							$logbuf = "Done processing.  Archived job file " . $file . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
					}
				}

				# snapshot edit schedule.
				if($functionName eq "snapshotEditSchedule") {

					$status = do_snapshotEditSchedule($path, $snapSched);

					# test mode = false
					#if( $test != 0) {	
					#	printf(RESULT "USER = %s\n", $userName);
					#	printf(RESULT "COMMAND = snapshotEditSchedule\n");
					#	printf(RESULT "PATH = $userPath\n");
					#}

					# operation failed.
					if($status == -1) {

						# operation unsuccessful.
						# test mode = false
						#if( $test != 0) {	
						#	printf(RESULT "Error !!!\n");
						#}
	
						# send email alert.
						#$mailBuf = "ERROR !!! Unable to process job file $file. Reason: 10";
						#&mailVCAD($mailBuf);

						# write error message to log file.
						$logbuf = " ERROR !!! Unable to process job file " . $file;
						$log = 1;
						writeLog($log, $debug, $verbose, "red", $logbuf);

						# invalidate the job file.
						$result = invalidateJob($file, $chPath);

						# job file invalidated.
						if($result == 0) {

							# write to the log file.
							$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						} else {

							# unable to invalidate the job file.
							
							# send email alert.
							$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
							&mailVCAD($mailBuf);

							# write to the log file.
							$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);
						}

						# go to the next job file.
						$nextflag = 0;
                                                $message = "error executing snapshotEditSchedule";
						goto NEXT;
					} else {	

						# operation successful.
						# archive the job file.
						$result = archiveJob($file, $chPath);

						# job file archived.
						if($result == 0) {

							# process the current job file.
							$nextflag = 1;

							# write to the log file.
							$logbuf = "Done processing.  Archived job file " . $file;
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						} else {

							# unable to archive job file	
							# write to the log file.
							$logbuf = "ERROR !!! Unable to archive job file !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "SUCCESS, Unable to archive job file";
							goto NEXT;
						}

						# test mode = false
						#if( $test != 0) {	
						#	printf(RESULT "OUPUT = \n\n");
						#	printf(RESULT "%s\n\n", $status);
						#	printf(RESULT "Done !!!\n");
						#}

						# write to the log file.
							$logbuf = "Done processing.  Archived job file " . $file;
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
					}
				}

				# snapshot delete.
				if($functionName eq "snapshotDelete") {

					$status = do_snapshotDelete($path, $snapName);

					# test mode = false
					#if( $test != 0) {	
					#	printf(RESULT "USER = %s\n", $userName);
					#	printf(RESULT "COMMAND = snapshotDelete\n");
					#	printf(RESULT "PATH = $userPath\n");
					#}

					# operation failed.
					if($status == -1) {

						# operation unsuccessful.
						# test mode = false
						#if( $test != 0) {	
						#	printf(RESULT "Error !!!\n");
						#}

						# send email alert.
						#$mailBuf = "ERROR !!! Unable to process job file $file. Reason: 11";
						#&mailVCAD($mailBuf);

						# write error message to log file.
						$logbuf = "ERROR !!! Unable to process job file " . $file . ".";
						$log = 1;
						writeLog($log, $debug, $verbose, "blue", $logbuf);

						# invalidate the job file.
						$result = invalidateJob($file, $chPath);

						# job file invalidated.
						if($result == 0) {

							# write to the log file.
							$logbuf = "Moved JOBFILE to " . $chPath . "/.failed";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						} else {

							# unable to invalidate the job file.
							
							# send email alert.
							$mailBuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
							&mailVCAD($mailBuf);

							# write to the log file.
							$logbuf = "ERROR !!! Unable to invalidate job file: " . $file . " !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);
						}

						# go to the next job file.
						$nextflag = 0;
                                                $message = "error executing snapshotDelete";
						goto NEXT;
					} else {	

						# operation successful.
						# archive the job file.
						$result = archiveJob($file, $chPath);

						# job file archived.
						if($result == 0) {

							# process the current job file.
							$nextflag = 1;

							# write to the log file.
							$logbuf = "Done processing.  Archived job file " . $file . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
						} else {

							# unable to archive job file	
							# write to the log file.
							$logbuf = "ERROR !!! Unable to archive job file !!!";
							$log = 1;
							writeLog($log, $debug, $verbose, "red", $logbuf);

							# go to the next job file.
							$nextflag = 0;
                                                        $message = "SUCCESS, Unable to archive job file";
							goto NEXT;
						}

						# test mode = false
						#if( $test != 0) {	
						#	printf(RESULT "OUPUT = \n\n");
						#	printf(RESULT "%s\n\n", $status);
						#	printf(RESULT "Done !!!\n");
						#}

						# write to the log file.
							$logbuf = "Done processing.  Archived job file " . $file . ".";
							$log = 1;
							writeLog($log, $debug, $verbose, "blue", $logbuf);
					}
				}

				# exit label for next iteration
				NEXT:

                                my $info;
                                if ($test != 0) {
                                    #write message in result file
                                    $info  = "========================= job status ============================\n\n";
                                    $info .= "chamber           : $chamberName\n"  if ($chamberName ne "NULL");
                                    $info .= "job               : " . basename($file) . "\n";
                                    $info .= "command           : $functionName\n" if ($functionName ne "NULL");
                                    $info .= "path              : $userPath\n"     if ($userPath ne "NULL");
                                    $info .= "user              : $userName\n"     if ($userName ne "NULL");
                                    $info .= "permission        : $permissions\n"  if ($permissions ne "NULL");
                                    $info .= "snapshot name     : $snapName\n"     if ($snapName ne "NULL");
                                    $info .= "snapshot schedule : $snapSched\n"    if ($snapSched ne "NULL");
                                    $info .= "target user id    : $toUID\n"        if ($toUID ne "NULL");
                                    $info .= "source user id    : $fromUID\n"      if ($fromUID ne "NULL");
                                    $info .= "target group id   : $toGID\n"        if ($toGID ne "NULL");
                                    $info .= "recurisive        : $recursive\n"    if ($recursive ne "NULL");
                                    $info .= "server            : $server\n"       if ($server ne "NULL");
                                    $info .= "pid               : $pid\n"          if ($pid ne "NULL");
                                    $info .= "-----------------------------------------------------------------\n\n";
                                }


				# did we encounter any errors ??? YES !!!
				if($nextflag == 0) {

					$logbuf = "ERROR processing... Proceeding to the next job file.";
					$log = 0;
					writeLog($log, $debug, $verbose, "red", $logbuf);
                                        
                                        if ($test != 0) {
                                           if ($message =~ /SUCCESS/) {
                                              $info .= "result  : success\n";
                                           } else {
                                              $info .= "result  : fail\n";
                                              $info .= "reason  : $message\n";
                                           }
                                        }
                                       
				} else {
                                        if ($test != 0) {
                                           $info .= "result  : success\n\n";
                                           if ($message =~ /SUCCESS/) {
                                              $message =~ s/SUCCESS,\s*//g;
                                              $info .= "output  : $message\n";
                                           }
                                        }

					$logbuf = "Done processing... Proceeding to the next job file.";
					$log = 0;
					writeLog($log, $debug, $verbose, "blue", $logbuf);
				}
                                $info .= "=================================================================\n\n";

                                #output operation message to result file
                                if ($test != 0) {
                                   print RESULT $info;
                                   close RESULT;
                                }

                                # change ownership and permissions of result file to user name.
                                my ($mylogin,$mypass,$myuid,$mygid) = getpwnam($userName)
                                        or die "$userName not in passwd file";

                                my @DIR = $resultFile;
                                chown($myuid, $mygid, @DIR);

                                #mail vcaddem about the failure
                                if ($nextflag == 0) {
                                   if ($info =~ /result\s+:\s+fail/) {
                                      $info =~ s/\n/\r/g;
                                      &mailVCAD($info);
                                   }
                                }

			}

			# proceed to next chamber.
			NEXTCHAMBER:

			# did we encounter any errors ??? YES !!!
			if($nextchamberflag == 0) {

                                #shiqun: not printing out this info, other the log file
                                #        would be huge.
				#$logbuf = "Proceeding to the next chamber...";
				#$log = 0;
				#writeLog($log, $debug, $verbose, "blue", $logbuf);
			} else {

				$logbuf = "Processed all job files... Proceeding to the next chamber...";
				$log = 0;
				writeLog($log, $debug, $verbose, "blue", $logbuf);
			}
			#clearMountedPath();
		}
	} else {

		# verbose = true
		$logbuf = "Admin Module not implemented in chamber" . $chPrefix . $chNum . ".";
		$log = 0;
                ###shiqun: do not write if no such dropbox installed, since there will be
                ###        so many such lines in log file as the program will keep running all the
                ###        time for every chamber.
		#writeLog($log, $debug, $verbose, "red", $logbuf);
	}
}

# close the log file.
#printf(LOGFILE "\n\n");
close(LOGFILE);

# function to send email alerts.
sub mailVCAD {
	my $buf = shift;

	system("echo $buf | mailx -s \"Admin Module Job Fails\" zhehan");
	#system("echo $buf | mailx -s \"Admin Module Job Fails\" jane");
	# To be used for testing and debugging.  Replace vcaddem with personal user-id 
	# so that we don't spam everyone :)
	#system("echo $buf | mailx -s \"Admin Module Alert\" bhushan");
}

# function to validate the project name.
sub validateProject {
	my $projectName = shift;
	my $valid = 1;

	# write to the log file.
	$logbuf = "In function validateProject().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# open the NIS map file for projects.
	open(PROJFILE, "<", $ypProjFile)
		or die "Can't open file $ypProjFile: $!\n";

	foreach $line (<PROJFILE>) {
		if(($line =~ /^\s+$/) || ($line =~ /^\#/)) {
		} else {
			my @buf = split(/\s+/, $line);
			chomp($buf[0]);
			if($projectName eq $buf[0]) {
				$valid = 0;
				last;
			} else {
				$valid = 1;
			}
		}
	}
	close(PROJFILE);

	# return the status.
	return($valid);
}

# function to validate the rscratch name.
sub validateRscratch {
	my $projectName = shift;
	my $valid = 1;

	# write to the log file.
	$logbuf = "In function validateRscratch().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# open the NIS map file for projects.
	open(PROJFILE, "<", $ypRscratchFile)
		or die "Can't open file $ypRscratchFile: $!\n";

	foreach $line (<PROJFILE>) {
		if(($line =~ /^\s+$/) || ($line =~ /^\#/)) {
		} else {
			my @buf = split(/\s+/, $line);
			chomp($buf[0]);
			if($projectName eq $buf[0]) {
				$valid = 0;
				last;
			} else {
				$valid = 1;
			}
		}
	}
	close(PROJFILE);

	# return the status.
	return($valid);
}

# function to validate process hosted volume
sub validateProcessHosted {
        my $valid = 1;
        # write to the log file.
        $logbuf = "In function validateProcessHosted().";
        $log = 1;
        writeLog($log, $debug, $verbose, "blue", $logbuf);

        # open the NIS map file for projects.
        open(PROCESSFILE, "<", $ypProcessFile)
                or die "Can't open file $ypProcessFile: $!\n";

        foreach $line (<PROCESSFILE>) {
                if(($line =~ /^\s+$/) || ($line =~ /^\#/)) {
                } else {
                        my @buf = split(/\s+/, $line);
                        chomp($buf[0]);
                        if($buf[0] eq "hosted") {
                                $valid = 0;
                                last;
                        } else {
                                $valid = 1;
                        }
                }
        }
        close(PROCESSFILE);

        # return the status.
        return($valid);
}

# function to validate apps hosted volume
sub validateAppsHosted {
        my $valid = 1;
        # write to the log file.
        $logbuf = "In function validateAppsHosted().";
        $log = 1;
        writeLog($log, $debug, $verbose, "blue", $logbuf);

        # open the NIS map file for projects.
        open(APPSFILE, "<", $ypAppsFile)
                or die "Can't open file $ypAppsFile: $!\n";

        foreach $line (<APPSFILE>) {
                if(($line =~ /^\s+$/) || ($line =~ /^\#/)) {
                } else {
                        my @buf = split(/\s+/, $line);
                        chomp($buf[0]);
                        if($buf[0] eq "hosted") {
                                $valid = 0;
                                last;
                        } else {
                                $valid = 1;
                        }
                }
        }
        close(APPSFILE);

        # return the status.
        return($valid);
}

#validate license port
sub validatePort {
   my $ch = shift;
   my $server = shift;
   my $Port   = shift;
   my $valid  = 1;

   # write to log file
   $logbuf = "in function validatePort().";
   $log = 1;
   writeLog($log, $debug, $verbose, "blue", $logbuf);

   #first test if root can ssh to the server or not
   #from of course chamber zero
   my $sshtest = `ssh $server test -d /tmp && echo OK || echo NOK`;
   if ($sshtest =~ /NOK/) {
      writeLog($log, $debug, $verbose, "blue", "reason: cannot ssh to host $server");
      return $valid;
   }
   #only find lic.<daemon> and skip lic.<daemon>.<date> in /cc/cm_admin_ch??/cm_admin
   $ch =~ s/^..//;
   my $licdir = "/cc/cm_admin_ch$ch/cm_admin";
   my $status = `/grid/common/bin/find $licdir/lic* -name "lic.*" -not -name "lic.*.*" | xargs grep -i '^server' | grep $port`; 
   if (length($status) > 1) {
      $valid = 0;
      writeLog($log, $debug, $verbose, "blue", "license port check passed");  
   } else {
      $valid = 1;
      writeLog($log, $debug, $verbose, "blue", "reason: cannot find license file with server port $port on server $server");  
   }
   return $valid;
}



sub validatePID {
   my $server = shift;
   my $pid = shift;
   my $valid = 1;
   
   # write to log file
   $logbuf = "in function validatePID().";
   $log = 1;
   writeLog($log, $debug, $verbose, "blue", $logbuf);

   #first test if root can ssh to the server or not
   #from of course chamber zero
   my $sshtest = `ssh $server test -d /tmp && echo OK || echo NOK`;
   if ($sshtest =~ /NOK/) {
      writeLog($log, $debug, $verbose, "blue", "reason: cannot ssh to host $server");
      return $valid;
   }

   #get the pid info
   my $pidinfo = `ssh $server "ps -e -o 'user pid'" | grep $pid`;
   my $owner = (split(/\s+/, $pidinfo))[0];
   if (($owner eq 'root') or
       ($owner eq 'ccops') or
       ($owner eq 'ctxsrvr') or
       ($owner eq 'sgeadmin') or
       ($owner eq 'svnadmin')) {
      $valid = 1;
      writeLog($log, $debug, $verbose, "blue", "reason: $owner process"); 
   } else {
      my $localacc = `ypmatch $owner passwd`;
      # local account are special account which not in nis system.
      if ($localacc =~ /Reason: /) {
         $valid = 1;
         writeLog($log, $debug, $verbose, "blue", "reason: local account $owner process");
      } else {
         $valid = 0;
         writeLog($log, $debug, $verbose, "blue", "ok to kill pid %pid of user $owner");
      }
   }
   return $valid;
}

sub validateHost {
   my $chamberName = shift;
   my $server      = shift;
   my $valid = 1;

   # write to log file
   $logbuf = "in function validateHost().";
   $log = 1;
   writeLog($log, $debug, $verbose, "blue", $logbuf);

   if ($server !~ /^$chamberName/) {
      return $valid;
   }

   my $ypout = `ypmatch $server hosts`;
   if ($ypout =~ /ypbind/) {
      writeLog($log, $debug, $verbose, "blue", "reason: not running ypbind");
      $valid = 1;
   } elsif ($ypout =~ /match key/) {
      writeLog($log, $debug, $verbose, "blue", "reason: No such key in map");
      $valid = 1;
   } elsif ($ypout =~ /$server$/) {
      $valid = 0;
   } else {
      writeLog($log, $debug, $verbose, "blue", "reason: do not know");
      $valid = 1;
   }
   return $valid;
}
      


# function to log messages.
# log -> normal log messages.
# nolog -> no log messages.
# debug -> debug log messages.
# nodebug -> no debug log messages.
# verbose -> verbose messages to console.
# red -> use red color.
# blue -> use blue color.
# noverbose -> no verbose messages.
# blue -> no color.
sub writeLog {
	my $log = shift;
	my $debug = shift;
	my $verbose = shift;
	my $color = shift;
	my $msg = shift;

	if($log == 0) {
		printf(LOGFILE "$msg\n");
	}

	if($debug == 0) {
		printf(LOGILFE "DEBUGINFO: $msg\n");
	}

	if($verbose == 0) {
		if($color eq "red") {
			print BOLD, RED, ON_YELLOW, "$msg", RESET, "\n";
		}

		if($color eq "blue") {
			print BOLD, BLUE, "$msg", RESET, "\n";
		}
	}
}


# function to check the user type.
# return "0" is cadence engineer.
# return "1" if customer
sub checkUserType {
	my $name = shift;
	my $valid = -1;
	my $line;
	my $login;
	my $loginUID;

	# write to the log file.
	$logbuf = "In function checkUserType().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# open the NIS passwd file.
	open(PASSWD, "<", $ypPassFile)
		or die "Can't open passwd file $ypPassFile: $!\n";

	# parse the passwd file.
	foreach $line (<PASSWD>) {

		# split the line in the passwd file on ":"
		# capture the 1st argument as login name.
		# capture the 2nd argument as login uid.
		@pwline = split(/:/, $line);
		$login = $pwline[0];
		chomp($login);
		$loginUID = $pwline[2];
		chomp($loginUID);

		# check if the login name matches.
		# if they do, then check if uid is <= 80000.
		# if <= 80000, then valid = 1.
		# if > 80000, then valid = 0.
		if($name eq $login) {
			if($loginUID <= 80000) {

				# write to the log file.
				$logbuf = "User " . $name . " is a Cadence Engineer !!!";
				$log = 1;
				writeLog($log, $debug, $verbose, "red", $logbuf);

				# set valid = 0.
				$valid = 0;
			} else {

				# UID is > 80000.
				# set valid = 1.
				$valid = 1;
			}

			# escape the loop if we find a match.
			# else continue to the next line.
			last;
		} else {
			$valid = 1;
		}
	}

	close(PASSWD);
	
	# write to the log file.
	$logbuf = "Returning from function checkUserType().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# return the status.
	return($valid);
}

# function to validate the snapshot schedule.
# <digit><space><digit><space><digit>@<digit>(optional ,<digit>) 
sub validateSnapSchedule {
	my $schedule = shift;
	my @buf;
	my @schedules;
	my @times;
	my $valid = 1;

	# write to the log file.
	$logbuf = "In function validateSnapSchedule().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# determine if pattern is valid.	
	if($schedule =~ /^(\d\s\d\s\d)@(\d(\d)?\,)*?(\d(\d)?)$/) {
	
		# split valid pattern at "@".
		@buf = split(/@/, $schedule);

		# split 1st buffer at "\s".
		@schedules = split(/\s/, $buf[0]);

		# split 2nd buffer at ",".
		@times = split(/,/, $buf[1]);	

		# first buffer should be 3 digits only.
		# 3 digits => valid = 0.
		# not 3 digits => valid = 1.
		if($#schedules == 2) {
			$valid = 0;
		} else {
			$valid = 1;
			return($valid);
		}

		# end buffer should not be more than 23 digits.
		# each digit should be less than the next digit.
		# digit should not be greater than 23.
		if($#times <= 23) {
			for(my $i = 1; $i <= $#times; $i++) {
				if($times[$i] > 23) {
					$valid = 1;
					return($valid);
				}

				if($times[$i] <= $times[$i-1]) {
					$valid = 1;
					return($valid);
				} else {
					$valid = 0;
				} 
			}
		} else {
			$valid = 1;
		}
	} else {
		$valid = 1;
	}

	# write to the log file.
	$logbuf = "Returning from validateSnapSchedule().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# return the status.
	return($valid);
}

# function to validate the snapshot name.
# valid names are:
# hourly.0 to hourly.7
# nightly.1 to nightly.5
# can not modify nightly.0
# weekly.0 to weekly.1
sub validateSnapName {
	my $name = shift;
	my $valid = 1;

	# write to the log file.
	$logbuf = "In function validateSnapName().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# check the hourly snapshot name.
	if($name =~ /^hourly\.(0|1|2|3|4|5|6|7)$/) {
		$valid = 0;
	}

	# check the nightly snapshot name.
	if($name =~ /^nightly\.(1|2|3|4|5)$/) {
		$valid = 0;
	}

	# check the weekly snapshot name.
	if($name =~ /^weekly\.(0|1)$/) {
		$valid = 0;
	}

	# write to the log file.
	$logbuf = "Returning from validateSnapName().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# return the status.
	return($valid);
}

# function to validate the netApp path.
# check if path is a valid file or directory.
# path should not be a symbolic link.
sub validateNetAppPath {
	my $path = shift;
	my $valid = 1;

	# write to the log file.
	$logbuf = "In function validateNetAppPath().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# check if path is a valid file.
	if(-f $path) {
		$valid = 0;

		# write to the log file.
		$logbuf = "Path \"" . $path . "\" is a file.";
		$log = 1;
		writeLog($log, $debug, $verbose, "blue", $logbuf);
	}

	# check if path is a valid directory.
	if(-d $path) {
		$valid = 0;

		# write to the log file.
		$logbuf = "Path \"" . $path . "\" is a directory.";
		$log = 1;
		writeLog($log, $debug, $verbose, "blue", $logbuf);
	}

	# check if path is a valid file.
	if(-l $path) {
		$valid = 1;

		# write to the log file.
		$logbuf = "Path \"" . $path . "\" is a symbolic link.";
		$log = 1;
		writeLog($log, $debug, $verbose, "red", $logbuf);
	}

	# write to the log file.
	$logbuf = "Returning from validateNetAppPath().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# return the status.
	return($valid);
}

sub getAccessPath {
         my $path = shift;
         my $chamber = shift;
         my $newpath;
         my $partialPath;
         my $AccessPath = "";
         my $dfOP;
         my @dfBuf;
         my $cmd;

         # write to the log file.
         $logbuf = "In function getAccessPath().";
         $log = 1;
         writeLog($log, $debug, $verbose, "blue", $logbuf);

         # path begins with /home/
         if($path =~ /^\/home\//) {

                 # write to the log file.
                 $logbuf = "Path starts with /home/.";
                 $log = 1;
                 writeLog($log, $debug, $verbose, "blue", $logbuf);

                 # open NIS map file for homes
                 open(AUTOHOME, "<", $ypHomeFile)
                         or die "Can't open file $ypHomeFile: $!";

                 # parse each line.
                 foreach my $line (<AUTOHOME>) {
                         if(($line =~ /^\s+$/) || ($line =~ /^\#/)) {
                         } else {
                                 my @buf = split(/\s+/, $line);

                                 if($path =~ /\/$buf[0]\//) {
                                         $fpath = $buf[1];
                                         $fpath =~ s/\&/$buf[0]/;
                                         $AccessPath = mountFilerPath($fpath);
                                         $partialPath = substr($path, 5, length($path));
					 chomp($partialPath);
					 my @partialPathArray = split('/', $partialPath);
					 shift(@partialPathArray);
					 shift(@partialPathArray);
					 my $lastEle = pop(@partialPathArray);
					 $partialPath = "";
					 foreach my $i (@partialPathArray)
					  {
    						$partialPath .= "/$i";
					  }
					  $partialPath .= "/$lastEle";
                                         $AccessPath = $AccessPath . $partialPath;
					 print $AccessPath;
                                         last;
                                 }
                         }
                 }
                 close(AUTOHOME);
         }

         # path begins with /apps/hosted
         if($path =~ /^\/apps\/hosted\//) {

                 # write to the log file.
                 $logbuf = "Path starts with /apps/hosted.";
                 $log = 1;
                 writeLog($log, $debug, $verbose, "blue", $logbuf);

                 # open NIS map file for homes
                 open(AUTOAPPS, "<", $ypAppsFile)
                         or die "Can't open file $ypAppsFile: $!";

                 # parse each line.
                 foreach my $line (<AUTOAPPS>) {
                         if(($line =~ /^\s+$/) || ($line =~ /^\#/)) {
                         } else {
                                 my @buf = split(/\s+/, $line);

                                 #if($path =~ /$buf[0]/) {
                                 if($buf[0] eq "hosted") {
                                         $fpath = $buf[1];
                                         $fpath =~ s/\&/$buf[0]/;
                                         $AccessPath = mountFilerPath($fpath);
                                         # 12 means to remove /apps/hosted from $path
                                        $partialPath = substr($path, 12, length($path));
                                        $AccessPath = $AccessPath . $partialPath;
                                         last;
                                 }
                         }
                 }
                 close(AUTOAPPS);
         }

         if($path =~ /^\/process\/hosted\//) {

                 # write to the log file.
                 $logbuf = "Path starts with /process/hosted.";
                 $log = 1;
                 writeLog($log, $debug, $verbose, "blue", $logbuf);

                 # open NIS map file for homes
                 open(AUTOPROCESS, "<", $ypProcessFile)
                        or die "Can't open file $ypProcessFile: $!";

                # parse each line.
                foreach my $line (<AUTOPROCESS>) {
                        if(($line =~ /^\s+$/) || ($line =~ /^\#/)) {
                        } else {
                                my @buf = split(/\s+/, $line);

                                #if($path =~ /$buf[0]/) {
                                if($buf[0] eq "hosted") {
                                        $fpath = $buf[1];
                                        $fpath =~ s/\&/$buf[0]/;
                                        $AccessPath = mountFilerPath($fpath);
                                        # 12 means to remove /process/hosted from $path
                                        $partialPath = substr($path, 15, length($path));
                                         $AccessPath = $AccessPath . $partialPath;
                                         last;
                                 }
                         }
                 }
                 close(AUTOPROCESS);
         }



         # if path begins with /home, /apps/hosted, /process/hosted, then use the Access path.

         # path begins with /proj/, /project/ or /projects/
         if($path =~ /^\/pro(j|jects?)\/?/) {

                 # write to the log file.
                 $logbuf = "Path starts with \"/proj/\" or \"/project/\" or \"/projects/\".";
                 $log = 1;
                 writeLog($log, $debug, $verbose, "blue", $logbuf);

                 if(-f $path) {

                         # write to the log file.
                         $logbuf = "Path \"" . $path . "\" exists and is a file.";
                         $log = 1;
                         writeLog($log, $debug, $verbose, "blue", $logbuf);

                         #$cmd = sprintf("df -h %s", $path);
                         #$dfOP = readpipe($cmd);
                         #@dfBuf = split(/\s+/, $dfOP);
                         #$dfBuf[7] =~ s/^(.{2})./$1"0"/;
                         #$dfBuf[7] =~ s/^(.{5})./$1"0"/;
                         #$dfBuf[7] =~ s/"//g;
                         #$newpath = "/net/" . $dfBuf[7];
                         #$newpath =~ s/\://;
                         #chomp($newpath);
                         #$partialPath = substr($path, length($dfBuf[12]), length($path));
                         #$AccessPath = $newpath . $partialPath;

                         # bgk fix.
                         $AccessPath = $path;
                         chomp($AccessPath);

                 } elsif(-d $path) {

                         # write to the log file.
                         $logbuf = "Path \"" . $path . "\" exists and is a directory.";
                         $log = 1;
                         writeLog($log, $debug, $verbose, "blue", $logbuf);

                         #$cmd = sprintf("df -h %s/.", $path);
                         #$dfOP = readpipe($cmd);
                         #@dfBuf = split(/\s+/, $dfOP);
                         #$dfBuf[7] =~ s/^(.{2})./$1"0"/;
                         #$dfBuf[7] =~ s/^(.{5})./$1"0"/;
                         #$dfBuf[7] =~ s/"//g;
                         #$newpath = "/net/" . $dfBuf[7];
                         #$newpath =~ s/\://;
                         #chomp($newpath);
                         #$partialPath = substr($path, length($dfBuf[12]), length($path));
                         #$AccessPath = $newpath . $partialPath;

                         # bgk fix
                         $AccessPath = $path;
                         chomp($AccessPath);

                 } else {

                         # write to the log file.
                         $logbuf = "Path \"" . $path . "\" doesn't exist.";
                         $log = 0;
                         writeLog($log, $debug, $verbose, "red", $logbuf);
                 }
         }

         # path begins with /rscratch
         if($path =~ /^\/rscratch\/?/) {

                 # write to the log file.
                 $logbuf = "Path starts with \"/rscratch/\".";
                 $log = 1;
                 writeLog($log, $debug, $verbose, "blue", $logbuf);

                 if(-f $path) {

                         # write to the log file.
                         $logbuf = "Path \"" . $path . "\" exists and is a file.";
                         $log = 1;
                         writeLog($log, $debug, $verbose, "blue", $logbuf);

                         #$cmd = sprintf("df -h %s", $path);
                         #$dfOP = readpipe($cmd);
                         #@dfBuf = split(/\s+/, $dfOP);
                         #$dfBuf[7] =~ s/^(.{2})./$1"0"/;
                         #$dfBuf[7] =~ s/^(.{5})./$1"0"/;
                         #$dfBuf[7] =~ s/"//g;
                         #$newpath = "/net/" . $dfBuf[7];
                         #$newpath =~ s/\://;
                         #chomp($newpath);
                         #$partialPath = substr($path, length($dfBuf[12]), length($path));
                         #$AccessPath = $newpath . $partialPath;

                         # bgk fix.
                         $AccessPath = $path;
                         chomp($AccessPath);

                 } elsif(-d $path) {

                         # write to the log file.
                         $logbuf = "Path \"" . $path . "\" exists and is a directory.";
                        $log = 1;
                        writeLog($log, $debug, $verbose, "blue", $logbuf);

                        #$cmd = sprintf("df -h %s/.", $path);
                        #$dfOP = readpipe($cmd);
                        #@dfBuf = split(/\s+/, $dfOP);
                        #$dfBuf[7] =~ s/^(.{2})./$1"0"/;
                        #$dfBuf[7] =~ s/^(.{5})./$1"0"/;
                        #$dfBuf[7] =~ s/"//g;
                        #$newpath = "/net/" . $dfBuf[7];
                        #$newpath =~ s/\://;
                        #chomp($newpath);
                        #$partialPath = substr($path, length($dfBuf[12]), length($path));
                         #$AccessPath = $newpath . $partialPath;

                         # bgk fix
                         $AccessPath = $path;
                         chomp($AccessPath);

                 } else {

                         # write to the log file.
                         $logbuf = "Path \"" . $path . "\" doesn't exist.";
                         $log = 0;
                         writeLog($log, $debug, $verbose, "red", $logbuf);
                 }
         }

         # write to the log file.
         $logbuf = "Returning Access path = " . $AccessPath . ".";
         $log = 1;
         writeLog($log, $debug, $verbose, "blue", $logbuf);

         # write to the log file.
         $logbuf = "Returning from getAccessPath().";
         $log = 1;
         writeLog($log, $debug, $verbose, "blue", $logbuf);

         # return the Access path.
         return($AccessPath);
 }


sub validateAccessPath {
        my $path = shift;
        my $valid = 1;

        # write to the log file.
        $logbuf = "In function validateAccessPath().";
        $log = 1;
        writeLog($log, $debug, $verbose, "blue", $logbuf);
        print "PATH: $path\n";
        # check if path is a valid file.
        if(-f $path) {
                $valid = 0;

                # write to the log file.
                $logbuf = "Path \"" . $path . "\" is a file.";
                $log = 1;
                writeLog($log, $debug, $verbose, "blue", $logbuf);
        }

        # check if path is a valid directory.
        if(-d $path) {
                $valid = 0;

                # write to the log file.
                $logbuf = "Path \"" . $path . "\" is a directory.";
                $log = 1;
                writeLog($log, $debug, $verbose, "blue", $logbuf);
        }

        # check if path is a valid file.
        if(-l $path) {
                $valid = 1;

                # write to the log file.
                $logbuf = "Path \"" . $path . "\" is a symbolic link.";
                $log = 1;
                writeLog($log, $debug, $verbose, "red", $logbuf);
        }

        # write to the log file.
        $logbuf = "Returning from validateAccessPath().";
        $log = 1;
        writeLog($log, $debug, $verbose, "blue", $logbuf);

        # return the status.
        return($valid);
}



# function to get the netApp path.
sub getNetAppPath {
	my $path = shift;
	my $chamber = shift;
	my $newpath;
	my $partialPath;	
	my $netAppPath = "";
	my $dfOP;
	my @dfBuf;
	my $cmd;

	# write to the log file.
	$logbuf = "In function getNetAppPath().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# path begins with /home/
	if($path =~ /^\/home\//) {

		# write to the log file.
	  	$logbuf = "Path starts with /home/.";
		$log = 1;
		writeLog($log, $debug, $verbose, "blue", $logbuf);

		# open NIS map file for homes
		open(AUTOHOME, "<", $ypHomeFile)
			or die "Can't open file $ypHomeFile: $!";

		# parse each line.
		foreach my $line (<AUTOHOME>) {
			if(($line =~ /^\s+$/) || ($line =~ /^\#/)) {
			} else {
				my @buf = split(/\s+/, $line);

				if($path =~ /$buf[0]/) {
                                        #test if /net/sjstna0?/.. is reachable or not
                                        my $apath = $buf[1];
                                        $apath   =~ s/^(..)(..)/${1}00/;
                                        $apath   = "/net/" . $apath;
                                        chop($apath);
                                        $apath   =~ s/\://;
                                        $partialPath = substr($path, 6, length($path));
                                        $netAppPath = $apath . $partialPath;
                                        if (! -d $netAppPath && ! -f $netAppPath) {
                                           ##see if /net/sj00na0?/... is reachable or not
                                           $netAppPath =~ s#^/net/(..)(..)#/net/${1}st#;
                                           if (! -d $netAppPath && ! -f $netAppPath) {
                                              #mailVCAD("netAppPath does not exist: $netAppPath");
                                              #the validateNetAppPath will validate this.
                                           }
                                        }

					#$buf[1] =~ s/^(.{2})./$1"0"/;
					#$buf[1] =~ s/^(.{5})./$1"0"/;
					#$buf[1] =~ s/"//g;
					#$newpath = "/net/" . $buf[1];
					#chop($newpath);
					#$newpath =~ s/\://;
					#$netAppPath = $newpath . $partialPath;
				}
			}
		}
		close(AUTOHOME);
	} 

        # path begins with /apps/hosted
        if($path =~ /^\/apps\/hosted\//) {

                # write to the log file.
                $logbuf = "Path starts with /apps/hosted.";
                $log = 1;
                writeLog($log, $debug, $verbose, "blue", $logbuf);

                # open NIS map file for homes
                open(AUTOAPPS, "<", $ypAppsFile)
                        or die "Can't open file $ypAppsFile: $!";

                # parse each line.
                foreach my $line (<AUTOAPPS>) {
                        if(($line =~ /^\s+$/) || ($line =~ /^\#/)) {
                        } else {
                                my @buf = split(/\s+/, $line);

                                #if($path =~ /$buf[0]/) {
                                if($buf[0] eq "hosted") {
                                        #test if /net/sjstna0?/.. is reachable or not
                                        my $apath = $buf[1];
                                        $apath   =~ s/^(..)(..)/${1}00/;
                                        $apath   = "/net/" . $apath;
                                        chop($apath);
                                        $apath   =~ s/\://;
                                        $apath =~ s/\$OSNAME/Linux/;
                                        $apath =~ s/\$OSREL/entry/;
                                        $partialPath = substr($path, 13, length($path));
                                        $netAppPath = $apath . $partialPath;
                                        if (! -d $netAppPath && ! -f $netAppPath) {
                                           ##see if /net/sj00na0?/... is reachable or not
                                           $netAppPath =~ s#^/net/(..)(..)#/net/${1}st#;
                                           if (! -d $netAppPath && ! -f $netAppPath) {
                                              #mailVCAD("netAppPath does not exist: $netAppPath");
                                              #the validateNetAppPath will validate this.
                                           }
                                        }

                                        #$buf[1] =~ s/^(.{2})./$1"0"/;
                                        #$buf[1] =~ s/^(.{5})./$1"0"/;
                                        #$buf[1] =~ s/"//g;
                                        #$newpath = "/net/" . $buf[1];
                                        #chop($newpath);
                                        #$newpath =~ s/\://;
                                        #$netAppPath = $newpath . $partialPath;
                                        last;
                                }
                        }
                }
                close(AUTOAPPS);
        }

        if($path =~ /^\/process\/hosted\//) {

                # write to the log file.
                $logbuf = "Path starts with /process/hosted.";
                $log = 1;
                writeLog($log, $debug, $verbose, "blue", $logbuf);

                # open NIS map file for homes
                open(AUTOPROCESS, "<", $ypProcessFile)
                        or die "Can't open file $ypProcessFile: $!";

                # parse each line.
                foreach my $line (<AUTOPROCESS>) {
                        if(($line =~ /^\s+$/) || ($line =~ /^\#/)) {
                        } else {
                                my @buf = split(/\s+/, $line);

                                #if($path =~ /$buf[0]/) {
                                if($buf[0] eq "hosted") {
                                        #test if /net/sjstna0?/.. is reachable or not
                                        my $apath = $buf[1];
                                        $apath   =~ s/^(..)(..)/${1}00/;
                                        $apath   = "/net/" . $apath;
                                        chop($apath);
                                        $apath   =~ s/\://;
                                        $partialPath = substr($path, 16, length($path));
                                        $netAppPath = $apath . $partialPath;
                                        if (! -d $netAppPath && ! -f $netAppPath) {
                                           ##see if /net/sj00na0?/... is reachable or not
                                           $netAppPath =~ s#^/net/(..)(..)#/net/${1}st#;
                                           if (! -d $netAppPath && ! -f $netAppPath) {
                                              #mailVCAD("netAppPath does not exist: $netAppPath");
                                              #the validateNetAppPath will validate this.
                                           }
                                        }

                                        #$buf[1] =~ s/^(.{2})./$1"0"/;
                                        #$buf[1] =~ s/^(.{5})./$1"0"/;
                                        #$buf[1] =~ s/"//g;
                                        #$newpath = "/net/" . $buf[1];
                                        #chop($newpath);
                                        #$newpath =~ s/\://;
                                        #$netAppPath = $newpath . $partialPath;
                                        last;
                                }
                        }
                }
                close(AUTOPROCESS);
        }



	# bgk notes: temp fix.
	# due to the /net/ mounts, for paths beginning with /proj, i'll use the path as provided
	# if path begins with /home, then use the netapp path.

	# path begins with /proj/, /project/ or /projects/
	if($path =~ /^\/pro(j|jects?)\/?/) {

		# write to the log file.
		$logbuf = "Path starts with \"/proj/\" or \"/project/\" or \"/projects/\".";
		$log = 1;
		writeLog($log, $debug, $verbose, "blue", $logbuf);

		if(-f $path) {

			# write to the log file.
			$logbuf = "Path \"" . $path . "\" exists and is a file.";
			$log = 1;
			writeLog($log, $debug, $verbose, "blue", $logbuf);

			#$cmd = sprintf("df -h %s", $path);
			#$dfOP = readpipe($cmd);
			#@dfBuf = split(/\s+/, $dfOP);
			#$dfBuf[7] =~ s/^(.{2})./$1"0"/;
			#$dfBuf[7] =~ s/^(.{5})./$1"0"/;
			#$dfBuf[7] =~ s/"//g;
			#$newpath = "/net/" . $dfBuf[7];
			#$newpath =~ s/\://;
			#chomp($newpath);
			#$partialPath = substr($path, length($dfBuf[12]), length($path));
			#$netAppPath = $newpath . $partialPath;
			
			# bgk fix.
			$netAppPath = $path;
			chomp($netAppPath);
			
		} elsif(-d $path) {

			# write to the log file.
			$logbuf = "Path \"" . $path . "\" exists and is a directory.";
			$log = 1;
			writeLog($log, $debug, $verbose, "blue", $logbuf);
	
			#$cmd = sprintf("df -h %s/.", $path);
			#$dfOP = readpipe($cmd);
			#@dfBuf = split(/\s+/, $dfOP);
			#$dfBuf[7] =~ s/^(.{2})./$1"0"/;
			#$dfBuf[7] =~ s/^(.{5})./$1"0"/;
			#$dfBuf[7] =~ s/"//g;
			#$newpath = "/net/" . $dfBuf[7];
			#$newpath =~ s/\://;
			#chomp($newpath);
			#$partialPath = substr($path, length($dfBuf[12]), length($path));
			#$netAppPath = $newpath . $partialPath;

			# bgk fix
			$netAppPath = $path;
			chomp($netAppPath);
			
		} else {

			# write to the log file.
			$logbuf = "Path \"" . $path . "\" doesn't exist.";
			$log = 0;
			writeLog($log, $debug, $verbose, "red", $logbuf);
		}
	} 

	# path begins with /rscratch
	if($path =~ /^\/rscratch\/?/) {

		# write to the log file.
		$logbuf = "Path starts with \"/rscratch/\".";
		$log = 1;
		writeLog($log, $debug, $verbose, "blue", $logbuf);

		if(-f $path) {

			# write to the log file.
			$logbuf = "Path \"" . $path . "\" exists and is a file.";
			$log = 1;
			writeLog($log, $debug, $verbose, "blue", $logbuf);

			#$cmd = sprintf("df -h %s", $path);
			#$dfOP = readpipe($cmd);
			#@dfBuf = split(/\s+/, $dfOP);
			#$dfBuf[7] =~ s/^(.{2})./$1"0"/;
			#$dfBuf[7] =~ s/^(.{5})./$1"0"/;
			#$dfBuf[7] =~ s/"//g;
			#$newpath = "/net/" . $dfBuf[7];
			#$newpath =~ s/\://;
			#chomp($newpath);
			#$partialPath = substr($path, length($dfBuf[12]), length($path));
			#$netAppPath = $newpath . $partialPath;
			
			# bgk fix.
			$netAppPath = $path;
			chomp($netAppPath);
			
		} elsif(-d $path) {

			# write to the log file.
			$logbuf = "Path \"" . $path . "\" exists and is a directory.";
			$log = 1;
			writeLog($log, $debug, $verbose, "blue", $logbuf);
	
			#$cmd = sprintf("df -h %s/.", $path);
			#$dfOP = readpipe($cmd);
			#@dfBuf = split(/\s+/, $dfOP);
			#$dfBuf[7] =~ s/^(.{2})./$1"0"/;
			#$dfBuf[7] =~ s/^(.{5})./$1"0"/;
			#$dfBuf[7] =~ s/"//g;
			#$newpath = "/net/" . $dfBuf[7];
			#$newpath =~ s/\://;
			#chomp($newpath);
			#$partialPath = substr($path, length($dfBuf[12]), length($path));
			#$netAppPath = $newpath . $partialPath;

			# bgk fix
			$netAppPath = $path;
			chomp($netAppPath);
			
		} else {

			# write to the log file.
			$logbuf = "Path \"" . $path . "\" doesn't exist.";
			$log = 0;
			writeLog($log, $debug, $verbose, "red", $logbuf);
		}
	} 

	# write to the log file.
	$logbuf = "Returning netApp path = " . $netAppPath . ".";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# write to the log file.
	$logbuf = "Returning from getNetAppPath().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# return the netApp path.
	return($netAppPath);
}

# function to check if path is same as the auto mount point.
# check if path begins with /project, /proj, /projects.
# verify that the path provided is not same as the mount point.
# if same, then valid = 1 else valid = 0.
# if path is a link, then valid = 1.
# e.g., path = /proj/vcadsw.  mount point = /proj/vcadsw. => valid = 1.
# e.g., path = /proj/vcadsw/<some path to file or dir>. mount point = /proj/vcadsw. => valid = 0.
sub checkPROJmount {
	my $path = shift;
	my $valid = 1;

	# write to the log file.
	$logbuf = "In function checkPROJmount().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# check if path starts with /project/	
	# share functions for rscratch.
	if($path =~ /^\/pro(j|jects?)\/?/ || $path =~ /^\/rscratch\/?/) {

		# check if path is the top level directory.
		if(-d $path) {

			# do a disk free on the path.
			$cmd = sprintf("df -h %s/.", $path);
			$dfOP = readpipe($cmd);
			@dfBuf = split(/\s+/, $dfOP);

			# get the mounted on path.
			chomp($mountPath = pop(@dfBuf));

			# remove trailing "/" if present.
			$path =~ s/\/$//;

			# check if path is equal to mounted on path.
			# equal => valid = 1.
			# not equal => valid = 0.
			if($mountPath =~ /$path/) {
				$valid = 1;
			} else {
				$valid = 0;
			}
		}

		# check if path is a file and exists.
		# if path is a file => valid = 0.
		if(-f $path) {
			$valid = 0;
		} 

		# check if path is a link.
		# if path is a link => valid = 1.
		if(-l $path) {
			$valid = 1;
		}
	} 

	# write to the log file.
	$logbuf = "Returning from checkPROJmount().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# return the status.
	return($valid);
}	

# function to check if /home is a CDNS engineer's $HOME.
# check if path provided beings with /home/.
# split the string on "/" and capture the 2nd argument.
# if 2nd argument is a valid user then check if uid <= 80000.
# less than or equal to 80000 => cadence engineers' account.
# greater than 80000 => customer account.
sub checkCDNShome {
	my $path = shift;
	my $valid = 1;

	# write to the log file.
	$logbuf = "In function checkCDNShome().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# check if path beings with "/home/" 
	# split the path on "/" and capture the 2nd argument as the owner the path provided.
	if($path =~ /^\/home\//) {
		@homePathDirs = split(/\//, $path);
		$homeOwner = $homePathDirs[2];

		# open the NIS passwd file.
		open(PASSWD, "<", $ypPassFile)
			or die "Can't open passwd file $ypPassFile: $!\n";

		# parse the passwd file.
		foreach $line (<PASSWD>) {

			# split the line in the passwd file on ":"
			# capture the 1st argument as login name.
			# capture the 2nd argument as login uid.
			@pwline = split(/:/, $line);
			$login = $pwline[0];
			chomp($login);
			$loginUID = $pwline[2];
			chomp($loginUID);
	
			# check if the login name matches.
			# if they do, then check if uid is <= 80000.
			# if <= 80000, then valid = 1.
			# if > 80000, then valid = 0.
			if($homeOwner eq $login) {
				if($loginUID <= 80000) {
	
					# write to the log file.
					$logbuf = "ERROR !!! Can't modify path of user" . $homeOwner . ".";
					$log = 0;
					writeLog($log, $debug, $verbose, "red", $logbuf);
		
					$valid = 1;
				} else {
					$valid = 0;
				}

				# escape the loop if we find a match.
				# else continue to the next line.
				last;
			} else {
				$valid = 1;
			}
		}
		
		close(PASSWD);
	} 

	# write to the log file.
	$logbuf = "Returning from checkCDNShome().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# return the status.
	return($valid);
}



# function to validate the path entered by the user.
# should begin with /home or /proj or /project or /projects or /apps/hosted or /process/hosted
# should not be just /home or /proj or /project or /projects /apps/hosted or /process/hosted
# should not be /home/ccops
# should not be /home/cm_admin
sub validatePath {
	my $path = shift;
	my $valid = 1;
	my $cmd;
	my $dfOP;
	my @dfBuf;
	my $mountPath;
	my @homePathDirs;
	my $homeOwner;
	my $line;
	my $login;
	my $loginUID;
	my @pwline;
	my $status = -1;

	# write to the log file.
	$logbuf = "In function validatePath().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# check if path starts with /home/
	if($path =~ /^\/home\//) {

		# check if only /home/ is given.
		if($path =~ /^\/(home\/?)$/) {

			# write to the log file.
			$logbuf = "ERROR !!! Can't provide only /home/ as path !!!";
			$log = 0;
			writeLog($log, $debug, $verbose, "red", $logbuf);
			$valid = 1;
		} else {

			# path is not only /home.
			$valid = 0;

			# check if we're in /home/ccops
			if($path =~ /^\/home\/ccops\/?/) {
				$valid = 1;
			}

			# check if we're in /home/cm_admin
			if($path =~ /^\/home\/cm_admin\/?/) {
				$valid = 1;
			}
		}
	}

	# path should start with /proj(/)
	# path should not be ONLY /proj/
	# TO BE DONE:
	# invalid: /proj, /proj/, /proj/., /proj/.., /proj/bla/..
	# valid: /proj/bla/blub.x, /proj/bla/blub..x /proj/project/dir.old, 
	# /proj/bla/blub/.blah

	# check if path starts with /proj, /project, /projects
	if($path =~ /^\/pro(j|jects?)\/?/) {

		# check if only /home/ is given.
		if($path =~ /^\/(pro(j|jects?)\/?)$/) {

			# write to the log file.
			$logbuf = "ERROR !!! Can't provide only /proj, /project, /projects as path !!!";
			$log = 1;
			writeLog($log, $debug, $verbose, "red", $logbuf);
			$valid = 1;
		} else {

			# path is not only /proj or /project or /projects
			$valid = 0;
		} 
	}
        # check if path starts with /rscratch
        if($path =~ /^\/rscratch\/?/) {

                # check if only /rscratch/ is given.
                if($path =~ /^\/rscratch\/?$/) {

                        # write to the log file.
                        $logbuf = "ERROR !!! Can't provide only /rscratch as path !!!";
                        $log = 1;
                        writeLog($log, $debug, $verbose, "red", $logbuf);
                        $valid = 1;
                } else {

                        # path is not only /proj or /project or /projects
                        $valid = 0;
                }
        }
        if ($path =~ /^\/apps\/hosted\/?/) {
                # check if only /apps/hosted is given
                if ($path =~ /^\/apps\/hosted\/?$/) {
                       # write to the log file.
                        $logbuf = "ERROR !!! Can't provide only /apps/hosted as path !!!";
                        $log = 1;
                        writeLog($log, $debug, $verbose, "red", $logbuf);
                        $valid = 1;
                } else {

                        # path is not only /apps/hosted 
                        $valid = 0;
                }
        }
        if ($path =~ /^\/process\/hosted\/?/) {
                # check if only /process/hosted is given
                if ($path =~ /^\/process\/hosted\/?$/) {
                       # write to the log file.
                        $logbuf = "ERROR !!! Can't provide only /process/hosted as path !!!";
                        $log = 1;
                        writeLog($log, $debug, $verbose, "red", $logbuf);
                        $valid = 1;
                } else {

                        # path is not only /process/hosted 
                        $valid = 0;
                }
        }

	# write to the log file.
	$logbuf = "Returning from validatePath()";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# return the status.
	return($valid);
}

# function to validate the permissions input.
# valid values are "0", "1" or "2"
sub validatePermissions {
	my $ch = shift;
	my $valid = 1;

	# write to the log file.
	$logbuf = "In function validatePermissions().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# valid values for permissions.
	if($ch == 0) {
		$valid = 0;
	} elsif($ch == 1) {
		$valid = 0;
	} elsif($ch == 2) {
		$valid = 0;
	} elsif($ch == 3) {
                $valid = 0;
	} elsif($ch == 4) {
                $valid = 0;
        } else {

		# invalid value for permissions.
		$valid = 1;
	}

	# write to the log file.
	$logbuf = "Returning from validatePermissions().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# return the status.
	return($valid);
}

# function to check if there are any spaces in the input.
# input string should not contain special characters.
# '.' is remove since file name may have this char.
sub checkSpecialCharacters {
	my $name = shift;
	my $valid = 1;

	# write to the log file.
	$logbuf = "In function checkSpecialCharacters()";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	$logbuf = "Checking for special characters in \"" . $name . "\".";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# do we have any disallowed or special characters ???
	# yes => valid = 1.
	# no => valid = 0.
	if($name =~ /[\s\t\n\[\]\(\)\{\}\\\*\+\$\%\&\=\:\;\"\'\|`~!@]/) {

		# special characters found.
			$valid = 1;
	} else {

	# no special characters found.
		$valid = 0;
	}

	# write to the log file.
	$logbuf = "Returning from checkSpecialCharacters().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# return the status.
	return($valid);
}

# function to validate the GID input by the user.
sub validateGID {
	my $name = shift;
	my $group;
	my $line;
	my $valid = 1;

	# write to the log file.
	$logbuf = "In function validateGID().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# open the NIS group file.
	open(GROUP, "<", $ypGroupFile)
		or die "Can't open group file $ypGroupFile: $!\n";

	# parse the group file.
	foreach $line (<GROUP>) {
		@pwline = split(/:/, $line);
		$group = $pwline[0];
		chomp($group);
		if($name eq $group) {
			$valid = 0;

			# write to the log file.
			$logbuf = $name . " equals " . $group . ".";
			$log = 1;
			writeLog($log, $debug, $verbose, "blue", $logbuf);
			last;
		} else {
			$valid = 1;

			# write to the log file.
			$logbuf = $name . " NOT equals " . $group . ".";
			$log = 1;
			writeLog($log, $debug, $verbose, "red", $logbuf);
		}
	}

	# close the group file.
	close(GROUP);

	# check we are not lmadmin.
	if($name eq "lmadmin") {
		$valid = 1;
	}

	# check we are not sugroup.
	if($name eq "sugroup") {
		$valid = 1;
	}

	# write to the log file.
	$logbuf = "Returning from validateGID().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# return the status.
	return($valid);
}

# function to validate the UID input by the user.
# should be a valid user in the NIS passwd file for the chamber.
# UID should be > 500
sub validateUID {
	my $name = shift;
	my $login;
	my $loginUID;
	my $line;
	my $valid = 1;

	# write to the log file.
	$logbuf = "In function validateUID().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# open the NIS passwd file.
	open(PASSWD, "<", $ypPassFile)
		or die "Can't open passwd file $ypPassFile: $!\n";

	# parse the passwd file.
	foreach $line (<PASSWD>) {

		# split the line in passwd file on ":"
		# capture the 1st argument as login name.
		# capture the 2nd argument as login uid.
		@pwline = split(/:/, $line);
		$login = $pwline[0];
		chomp($login);
		$loginUID = $pwline[2];
		chomp($loginUID);

		if($name eq $login) {
			if($loginUID > 500) {
				$valid = 0;

				# write to the log file.
				$logbuf = $name . " equals " . $login . ".";
				$log = 1;
				writeLog($log, $debug, $verbose, "blue", $logbuf);

				$logbuf = "UID of " . $name . " = " . $loginUID . " which is > 500.";
				$log = 1;
				writeLog($log, $debug, $verbose, "blue", $logbuf);
			} else {
				$valid = 1;

				# write to the log file.
				$logbuf = "UID of " . $name . " = " . $loginUID . " which is <= 500.";
				$log = 1;
				writeLog($log, $debug, $verbose, "red", $logbuf);
			}
			last;
		} else {
			$valid = 1;

			# write to the log file.
			$logbuf = $name . " NOT equals " . $login . ".";
			$log = 1;
			writeLog($log, $debug, $verbose, "red", $logbuf);
		}
	}

	# close the NIS passwd file.
	close(PASSWD);

	# check we are not root.
	if($name eq "root") {
		$valid = 1;
	}

	# check we are not ccops.
	if($name eq "ccops") {
		$valid = 1;
	}

	# check we are not ctxssl.
	if($name eq "ctxssl") {
		$valid = 1;
	}

	# check we are not ctxsrvr.
	if($name eq "ctxsrvr") {
		$valid = 1;
	}

	# check we are not ctxladmin.
	if($name eq "ctxladmin") {
		$valid = 1;
	}

	# write to the log file.
	$logbuf = "Returning from validateUID().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# return the status.
	return($valid);
}


# function to validate the user name of the person running the program.
# check if user is allowed to run the admin module program.
# should be listed in .../cm_admin/dropBox/auth_users or administrators.
# should be valid user in passwd file.
sub validateUserName {
	my $user = shift;
	my $dropBoxPath = shift;
	my @authFileLines;
	my $authFile = $dropBoxPath . "/auth_users";
        my $adminFile = $dropBoxPath . "/administrators";
	my $valid = 1;
	my $avalid = 1;
	my $pvalid = 1;

	# write to the log file.
	$logbuf = "In function validateUserName().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# open the authorization file.
	open(CHFILE, "<", $authFile)
		or die "Can't open file $authFile: $!";

	# open the administrators file.
	open(ADMINFILE, "<", $adminFile)
		or die "Can't open file $adminFile: $!";

        close CHFILE;
        close ADMINFILE;

	# parse the authorization file.
	foreach my $line (`cat $authFile $adminFile`) {
		chomp($line);

		# user name match.
		if($user eq $line) {

			# set valid = 0.
			$avalid = 0;

			# write to the log file.
			$logbuf = $user . " equals " . $line . ".";
			$log = 1;
			writeLog($log, $debug, $verbose, "blue", $logbuf);

			# exit the loop.
			last;
		} else {

			# user name not yet matched.
			$avalid = 1;

			# write to the log file.
			$logbuf = $user . " NOT equals " . $line . ".";
			$log = 1;
			writeLog($log, $debug, $verbose, "red", $logbuf);
		}
	}


	# open the NIS passwd file.
	open(PASSWD, "<", $ypPassFile)
		or die "Can't open passwd file $ypPassFile: $!\n";

	# parse the passwd file.
	foreach my $line (<PASSWD>) {
		@pwline = split(/:/, $line);
		$login = $pwline[0];
		chomp($login);

		if($user eq $login) {
			$pvalid = 0;

			# write to the log file.
			$logbuf = $user . " equals " . $login . ".";
			$log = 1;
			writeLog($log, $debug, $verbose, "blue", $logbuf);
			last;
		} else {
			$pvalid = 1;

			# write to the log file.
			$logbuf = $user . " NOT equals " . $login . ".";
			$log = 1;
			writeLog($log, $debug, $verbose, "red", $logbuf);
		}
	}

	close(PASSWD);

	# write to the log file.
	$logbuf = "Returning from validateUserName().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	if(($avalid == 0) && ($pvalid == 0)) {
		$valid = 0;
	} else {
		$valid = 1;
	}

	# return the status.
	return($valid);
}



# function to validate the chamber name.
# chamber name should not be ba00, sj00, sh00, etc...
sub validateChambers {
	my $chname = shift;
	my $valid = 1;

	# write to the log file.
	$logbuf = "In function validateChambers().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# check if we're in chamber *ZERO*
	if($chname =~ /00/) {
		$valid = 1;

		# write to the log file.
		$logbuf = "Job trying to execute a program in chamber zero.";
		$log = 1;
		writeLog($log, $debug, $verbose, "red", $logbuf);
	} else {
		$valid = 0;

		# write to the log file.
		$logbuf = "Job NOT trying to execute a program in chamber zero.";
		$log = 1;
		writeLog($log, $debug, $verbose, "blue", $logbuf);
	}

	# write to the log file.
	$logbuf = "Returning from validateChambers().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# return the status.
	return($valid);
}

# function to get the chamber prefix for the site, e.g., (ba, sj, sh, etc...)
sub getSitePrefix {
	my $prefixOutput = `ypcat -k auto.cc | grep "chvc"`;
	my @prefixLine = split(/\s/, $prefixOutput);
	my $prefix = substr($prefixLine[2], 0,2);

	# write to the log file.
	$logbuf = "In function getSitePrefix().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	$logbuf = "Returning SITE prefix = " . $prefix . ".";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	$logbuf = "Returning from getSitePrefix().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# return site prefix.
	return($prefix);
}

# function to return the chamber list and location of the dropBox in each chamber.
# contains a list of chambers and path to the droBox separated by a colon, i.e., ":".
sub getChamberList {
	my $chamber = shift;
	my @ypcat_output;
	my @cm_admin_list;
	my @cm_admin_list_path;
	my $count = 0;

	# write to the log file.
	$logbuf = "In function getChamberList().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);
	# run ypcat for chambers.
	if($chamber eq "all") {
		# write to the log file.
		$logbuf = "Scanning all chambers.";
		$log = 1;
		writeLog($log, $debug, $verbose, "blue", $logbuf);
		@ypcat_output = `ypcat -k auto.cc | grep -i cm_admin_ch`;
	} else {

		# write to the log file.
		$logbuf = "Scanning chamber " . $chamber . ".";
		$log = 1;
		writeLog($log, $debug, $verbose, "blue", $logbuf);
		@ypcat_output = `ypcat -k auto.cc | grep -i $chamber`;
	}

	# remove newlines.
	chomp(@ypcat_output);

	# parse the output and get required information from *ypcat* output.
	foreach(@ypcat_output) {
		my @line = split(/\s/, $_);

		if($line[0] =~ /cm_admin_ch/) {
			$cm_admin_list_path[$count] = pop(@line);

			my $buffer = $line[0];
			chomp($cm_admin_list_path[$count]);
			chop($cm_admin_list_path[$count]);
			substr($cm_admin_list_path[$count],0 , 0, "/cc/");

			my @path_buffer = split(/\:/, $cm_admin_list_path[$count]);
			$cm_admin_list_path[$count] = join('', "/cc/", $buffer);
			substr($cm_admin_list_path[$count], length($cm_admin_list_path[$count]) , 0, "/cm_admin/dropBox");


			my @chamber_buffer = split(/_/, $buffer);
			$cm_admin_list[$count] = join(":", $chamber_buffer[2], $cm_admin_list_path[$count]);
			chomp($cm_admin_list_path[$count]);
		}
		++$count;
	}

	# write to the log file.
	$logbuf = "Returning value " . @cm_admin_list . ".";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	$logbuf = "Returning from getChamberList().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# return chamber list.
	return(@cm_admin_list);
}

# function to return the name of the results file.
# $USER/.cdns/<job name>.results
sub getResultFile {
	my $user = shift;
	my $chamber = shift;
	my $file = shift;
	my $fileBaseName;
	my $homeBuf;
	my $userHome;
	my $rfile;
	my $rpath;

	# write to the log file.
	$logbuf = "In function getResultFile().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# open the NIS map file for homes.
	open(AUTOHOME, "<", $ypHomeFile) 
		or die "Can't open file $ypHomeFile: $!";

	foreach my $line (<AUTOHOME>) {
                next if ($line =~ /^\s*\#/); #comment line
		if($line =~ /\b$user\b/) {   #should exactly match here
			my @buf = split(/\s+/, $line);
			$homeBuf = $buf[1];
                        last;                #last if find. 
		}
	}
	close(AUTOHOME);
	chomp($homeBuf);
	chomp($homeBuf);
	#chop($homeBuf);
	$homeBuf =~ s/\&/$user/g;
        $userHome = mountFilerPath($homeBuf);

        $rpath = $userHome . "/.cdns";


        #/net/sj00na0?/.../<user>/
        if (! -d $userHome) {
           #and try /net/sjstna0?/.../<user>
           $userHome =~ s#^/net/(..)(..)#/net/${1}st#;
        }
          
	$rpath = $userHome . "/.cdns";

	# check is $USER/.cdns exists.
	if(!-d $rpath) {

		# doesn't exist.
		# write to the log file.
		$logbuf = "\"" . $rpath . "\" doesn't exist.";
		$log = 1;
		writeLog($log, $debug, $verbose, "red", $logbuf);

		$logbuf = "Creating \"" . $rpath . "\" to store result files.";
		$log = 1;
		writeLog($log, $debug, $verbose, "blue", $logbuf);

		# create $USER/.cdns directory.
		mkdir($rpath);
		my ($mylogin,$mypass,$myuid,$mygid) = getpwnam($user)
			or die "$user not in passwd file";
		my @DIR = $rpath;

		# change permissions to $USER
		chown($myuid, $mygid, @DIR);
	}

	# get the complete path to the file name.
	$fileBaseName = basename($file);
	$rfile = $rpath . "/" . $fileBaseName . ".results";

	# write to the log file.
	$logbuf = "Returning results file = " . $rfile;
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# write to the log file.
	$logbuf = "Returning from getResultFile().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# return the file name.
	return($rfile);
}

sub mountFilerPath {
        my $fpath = shift;
        my $mntDir = "/tmp/adminModule_mnts";
        if( ! -d $mntDir ) {
                mkdir($mntDir);
        }
        my @set = ('0' ..'9', 'A' .. 'F');
        my $randstr = join '' => map $set[rand @set], 1 .. 8;
        my $mntPath = $mntDir . "/mnt." . $randstr;
        mkdir($mntPath);
        my @tmp = split(/:/, $fpath);
        my $filer = $tmp[0];
        if($filer =~ m/,/ ) {
                $filer = (split(/,/, $filer))[0];
        }
        # to use netApp filer chamber 0 interface
        $filer =~ s/stna/00na/;
        $fpath = $tmp[1];
        $fpath =~ s/\$OSNAME/Linux/;
        $fpath =~ s/\$OSREL/entry/;
        $fpath = $filer . ":" . $fpath;

        my $command = "mount";
        $command .= " -o rw,intr,soft";
        $command .= " $fpath $mntPath";
        my $exit_code = system($command);

        if ($exit_code == 0) {
            $logbuf = "\"" . $path . "/.mount successfull\" ";
            $log = 1;
            writeLog($log, $debug, $verbose, "blue", $logbuf);
        } else {
            $logbuf = "\"" . $path . "/.mount failed with exitcode: " . $exit_code . "\" ";
            $log = 1;
            writeLog($log, $debug, $verbose, "red", $logbuf);
        }

        return($mntPath);
}

sub clearMountedPath {
        my $mntDir = "/tmp/adminModule_mnts";
        if ( -d $mntDir ) {
                my @mntPaths = <$mntDir/mnt.*>;
                foreach my $mntPath (@mntPaths) {
                        system("umount $mntPath");
                        my @buf = <$mntPath/*>;
                        if($#buf < 0) {
                                rmdir($mntPath)
                        }
                }
                rmdir($mntDir);
        }
}


sub invalidateJob {
	my $file = shift;
	my $path = shift;
	my $valid = 1;
	my $retVal = 1;

	# write to the log file.
	$logbuf = "In function invalidateJob().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# check if the dropBox/.failed directory exists.
	if(-d "$path/.failed") {

		# write to the log file.
		$logbuf = "\"" . $path . "/.failed\" EXISTS !!!";
		$log = 1;
		writeLog($log, $debug, $verbose, "blue", $logbuf);
	} else {

		# write to the log file.
		$logbuf = "\"" . $path . "/.failed\" does NOT EXIST !!!";
		$log = 1;
		writeLog($log, $debug, $verbose, "blue", $logbuf);

		$logbuf = "creating path...";
		$log = 1;
		writeLog($log, $debug, $verbose, "blue", $logbuf);

		# create the $path/.failed directory.
		system("mkdir $path/.failed");
	}

	# test mode = false
	if($test == 1) {
		$retVal = system("mv $file $path/.failed");
		if($retVal == 0) {
			$valid = 0;
		} else {
			$valid = 1;
		}
	}

	# test mode = true
	if($test == 0) {
		printf(LOGFILE "*******************************************************************************\n");
		printf(LOGFILE "***TESTINFO: \"mv $file $path/.failed\"\n\n");
		printf(LOGFILE "*******************************************************************************\n");
		$retVal = 0;
		$valid = 0;
	}

	# write to the log file.
	$logbuf = "Returning from invalidateJob().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	$logbuf = "Moved JOBFILE to " . $path . "/.failed...";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# write to the log file.
	$logbuf = "Returning from invalidateJob().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# return the status.
	return($valid);
}

# function to archive the job file after processing is completed.
# mv ../dropBox/<job file> to ../dropBox/.archive/
sub archiveJob {
	my $file = shift;
	my $path = shift;
	my $valid = 1;
	my $retVal = 1;

	# write to the log file.
	$logbuf = "In function archiveJob().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# test mode = true	NO !!!
	# move job file to dropBox/.archive/
	# set valid = 0 if successful.
	# set valid = 1 if unsuccessful.
	if($test == 1) {
		$retVal = system("mv $file $path/.archive");
		if($retVal == 0) {
			$valid = 0;
		} else {
			$valid = 1;
		}
	}

	# are we in test mode ?	YES !!!
	# print to log file the command that would've been executed.
	# set valid = 0.
	if($test == 0) {
		printf(LOGFILE "*******************************************************************************\n");
		printf(LOGFILE "***TESTINFO: \"mv $file $path/.archive\"\n\n");
		printf(LOGFILE "*******************************************************************************\n");
		$retVal = 0;
		$valid = 0;
	}

	# write to the log file.
	$logbuf = "Archived \"" . $file . "\" to " . $path . "/.archive";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# write to the log file.
	$logbuf = "Returning from archiveJob().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# return the status.
	return($valid);
}

# function to return the name of the filer.
sub getFilerName {
	my $path = shift;
	my $dfOP;
	my @dfBuf;
	my @filerBuf;

	# write to the log file.
	$logbuf = "In function getFilerName().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);
	if(-f $path) {

		# write to the log file.
		$logbuf = "\"" . $path . "\" exists and is a file.";
		$log = 1;
		writeLog($log, $debug, $verbose, "blue", $logbuf);
		$cmd = sprintf("df -h %s", $path);
		$dfOP = readpipe($cmd);
		@dfBuf = split(/\s+/, $dfOP);
		@filerBuf = split(/\:/, $dfBuf[7]);
		$filerBuf[0] =~ s/^(.{2})./$1"0"/;
		$filerBuf[0] =~ s/^(.{5})./$1"0"/;
		$filerBuf[0] =~ s/"//g;
		chomp($$filerBuf[0]);
	} elsif(-d $path) {
	
		# write to the log file.
		$logbuf = "\"" . $path . "\" exists and is a directory.";
		$log = 1;
		writeLog($log, $debug, $verbose, "blue", $logbuf);
		$cmd = sprintf("df -h %s/.", $path);
		$dfOP = readpipe($cmd);
		@dfBuf = split(/\s+/, $dfOP);
		@filerBuf = split(/\:/, $dfBuf[7]);
		$filerBuf[0] =~ s/^(.{2})./$1"0"/;
		$filerBuf[0] =~ s/^(.{5})./$1"0"/;
		$filerBuf[0] =~ s/"//g;
		chomp($$filerBuf[0]);
	} else {

		# write to the log file.
		$logbuf = "\"" . $path . "\" does not exist.";
		$log = 1;
		writeLog($log, $debug, $verbose, "red", $logbuf);
	}

	# write to the log file.
	$logbuf = "Returning file name = " . $filerBuf[0] . ".";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# write to the log file.
	$logbuf = "Returning from getFilerName().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# return the filer name.
	return($filerBuf[0]);
}

# function to get the name of the volume.
sub getVolumeName {
	my $path = shift;
	my $dfOP;
	my @dfBuf;
	my @volumeBuf;

	# write to the log file.
	$logbuf = "In function getVolumeName.";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);
	if(-f $path) {

		# write to the log file.
		$logbuf = "\"" . $path . "\" exists and is a file.";
		$log = 1;
		writeLog($log, $debug, $verbose, "blue", $logbuf);
		$cmd = sprintf("df -h %s", $path);
		$dfOP = readpipe($cmd);
		@dfBuf = split(/\s+/, $dfOP);
		@volumeBuf = split(/\//, $dfBuf[7]);
		chomp($$volumeBuf[2]);
	} elsif(-d $path) {

		# write to the log file.
		$logbuf = "\"" . $path . "\" exists and is a directory.";
		$log = 1;
		writeLog($log, $debug, $verbose, "blue", $logbuf);
		$cmd = sprintf("df -h %s/.", $path);
		$dfOP = readpipe($cmd);
		@dfBuf = split(/\s+/, $dfOP);
		@volumeBuf = split(/\//, $dfBuf[7]);
		chomp($$volumeBuf[2]);
	} else {

		# write to the log file.
		$logbuf = "ERROR !!! \"" . $path . "\" does not exist.";
		$log = 1;
		writeLog($log, $debug, $verbose, "red", $logbuf);
	}

	# write to the log file.
	$logbuf = "Returning volume = " . $volumeBuf[2] . ".";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# write to the log file.
	$logbuf = "Returning from getVolumeName().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# return the volume name.
	return($volumeBuf[2]);
}

# function to edit the snapshot schedule.
sub do_snapshotEditSchedule {
	my $path = shift;
	my $snapSched = shift;
	my $filer;
	my $volume;

	# write to the log file.
	$logbuf = "In function do_snapshotEditSchedule().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	if(-e $path) {

		# write to the log file.
		$logbuf = "\"" . $path . "\" exists.";
		$log = 1;
		writeLog($log, $debug, $verbose, "blue", $logbuf);
		$filer = getFilerName($path);
		$volume = getVolumeName($path);
		$cmd = sprintf("rsh %s snap sched %s \"%s\"", $filer, $volume, $snapSched);

		# test mode = true
		if($test == 1) {
			system($cmd);
		}

		# test mode = true
		if($test == 0) {
			printf(LOGFILE "*******************************************************************************\n");
			printf(LOGFILE "***TESTINFO: \"rsh $filer snap sched $volume %snapSched\"\n\n");
			printf(LOGFILE "*******************************************************************************\n");
			return(1);
		}

		# write to the log file.
		$logbuf = "Executing \"" . $cmd . "\".";
		$log = 1;
		writeLog($log, $debug, $verbose, "blue", $logbuf);
	} else {

		# write to the log file.
		$logbuf = "Error executing \"" . $cmd . "\".";
		$log = 1;
		writeLog($log, $debug, $verbose, "red", $logbuf);
		return(-1);
	}
}

# function to delete a snapshot.
sub do_snapshotDelete {
	my $path = shift;
	my $snapName = shift;
	my $filer;
	my $volume;

	# write to the log file.
	$logbuf = "In function do_snapshotDelete().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);
	if(-e $path) {

		# write to the log file.
		$logbuf = "\"" . $path . "\" exists.";
		$log = 1;
		writeLog($log, $debug, $verbose, "blue", $logbuf);

		$filer = getFilerName($path);
		$volume = getVolumeName($path);
		$cmd = sprintf("rsh %s snap delete %s %s", $filer, $volume, $snapName);

		# test mode = true
		if($test == 1) {
			system($cmd);
		}

		# test mode = true
		if($test == 0) {
			printf(LOGFILE "*******************************************************************************\n");
			printf(LOGFILE "***TESTINFO: \"rsh $filer snap delete $volume %snapName\"\n\n");
			printf(LOGFILE "*******************************************************************************\n");
		}

		# write to the log file.
		$logbuf = "Executing \"" . $cmd . "\".";
		$log = 1;
		writeLog($log, $debug, $verbose, "blue", $logbuf);
	} else {

		# write to the log file.
		$logbuf = "Error executing \"" . $cmd . "\".";
		$log = 1;
		writeLog($log, $debug, $verbose, "red", $logbuf);
		return(-1);
	}
}

# function to list the snapshots and display the snapshot schedule.
sub do_snapshotListAndShow {
	my $path = shift;
	my $filer;
	my $volume;
	my $op;
	my $op1;
	my $op2;

	# write to the log file.
	$logbuf = "In function do_snapshotListAndShow().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	if(-e $path) {

		# write to the log file.
		$logbuf = "\"" . $path . "\" exists.";
		$log = 1;
		writeLog($log, $debug, $verbose, "blue", $logbuf);

		$filer = getFilerName($path);
		$volume = getVolumeName($path);
		$cmd = sprintf("rsh %s snap list %s", $filer, $volume);

		# test mode = false.
		if($test == 1) {
			$op1 = `$cmd 2>&1`;
		}

		# test mode = true.
		if($test == 0) {
			printf(LOGFILE "*******************************************************************************\n");
			printf(LOGFILE "***TESTINFO: \"rsh $filer snap list $volume\"\n\n");
			printf(LOGFILE "*******************************************************************************\n");
		}
		$cmd = sprintf("rsh %s snap sched %s", $filer, $volume);

		# write to the log file.
		$logbuf = "Executing \"" . $cmd . "\".";
		$log = 1;
		writeLog($log, $debug, $verbose, "blue", $logbuf);

		# test mode = true
		if($test == 1) {
			$op2 = `$cmd 2>&1`;
		}

		# test mode = true
		if($test == 0) {
			printf(LOGFILE "*******************************************************************************\n");
			printf(LOGFILE "***TESTINFO: \"rsh $filer snap sched $volume\"\n\n");
			printf(LOGFILE "*******************************************************************************\n");
		}
		$op = sprintf("SNAPSHOT LIST\n%s\n\nSNAPSHOT SCHEDULE\n%s", $op1, $op2);

		# write to the log file.
		$logbuf = "Returning output \"" . $op . "\".";
		$log = 1;
		writeLog($log, $debug, $verbose, "blue", $logbuf);

		# return the output.
		return($op);
	} else {

		# write to the log file.
		$logbuf = "Error executing \"" . $cmd . "\".";
		$log = 1;
		writeLog($log, $debug, $verbose, "red", $logbuf);

		# return failure.
		return(-1);
	}
}

# function to perform a disk usage on the given path.
sub do_du {
	my $path = shift;
	my $op;

	# write to the log file.
	$logbuf = "In function do_du().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	if(-e $path) {

		# write to the log file.
		$logbuf = "\"" . $path . "\" exists.";
		$log = 1;
		writeLog($log, $debug, $verbose, "red", $logbuf);
		$cmd = sprintf("/apps/cc/utils/du.pl -h -d 1 %s", $path);

		# write to the log file.
		$logbuf = "Executing \"" . $cmd . "\"";
		$log = 1;
		writeLog($log, $debug, $verbose, "blue", $logbuf);

		# test mode = true
		if($test == 1) {
			$op = `$cmd 2>&1`;
		}

		# test mode = true
		if($test == 0) {
			printf(LOGFILE "*******************************************************************************\n");
			printf(LOGFILE "***TESTINFO: \"/apps/cc/utils/du.pl -h -d 1 $path\"\n\n");
			printf(LOGFILE "*******************************************************************************\n");
		}

		# write to the log file.
		$logbuf = "Returning output \"" . $op . "\".";
		$log = 1;
		writeLog($log, $debug, $verbose, "blue", $logbuf);
		return($op);
	} else {

		# write to the log file.
		$logbuf = "Error executing \"" . $cmd . "\".";
		$log = 1;
		writeLog($log, $debug, $verbose, "red", $logbuf);
		return(-1);
	}
}

#perform the kill function
sub do_kill {
	my $server = shift;
        my $pid    = shift;
	my $retVal = 1;
	my $valid = 1;

	# write to the log file.
	$logbuf = "In function do_kill().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# write to the log file.
	$logbuf = "server: $server, pid: $pid";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	$cmd = "ssh $server kill -9 $pid";

	# write to the log file.
	$logbuf = "Executing \"" . $cmd . "\".";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# test mode = true
	if($test == 1) {
		$retVal = system($cmd);
		if($retVal == 0) {
			$valid = 0;
		} else {
			$valid = 1;
		}
	}

	# test mode = true
	if($test == 0) {
		printf(LOGFILE "*******************************************************************************\n");
		printf(LOGFILE "***TESTINFO: \"kill pid $pid on host $server\"\n\n");
		printf(LOGFILE "*******************************************************************************\n");
		$valid = 0;
        } 

	# write to the log file.
	$logbuf = "Returning from do_kill().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# return the status.
	return($valid);
}

sub do_licmanage {
	my $server = shift;
        my $port   = shift;
	my $retVal = 1;
        my $valid  = 0;

	# write to the log file.
	$logbuf = "In function do_licmanage().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# write to the log file.
	$logbuf = "server: $server, port: $port";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

        #write function implementation here
        #1. figure out the license file
        my $ch = $server;
        $ch =~ s/[ut|lv|lo].*$//;
        my $chid = $ch;
        $chid =~ s/^..//;
        my $cmdir= '/cc/cm_admin_ch' . $chid . '/cm_admin';
        my $find = "/grid/common/bin/find";
        my $licfiles = `$find $cmdir/lic* -name 'lic.*' -not -name 'lic.*.*'|grep -i -v old | grep -i -v archive`;
        my $licfile = "";
        foreach my $f (split(/\n/, $licfiles)) {
           if (`grep -i '^server.*$port' $f`) {
              $licfile = $f;
              last;
           }
        }
        if ($licfile eq  "") {
           writeLog($log, $debug, $verbose, "blue", "No license file found");
           return 1;
         }
 
        #get owner of license file
        my $owner = (split(/\s+/,`ls -l $licfile`))[2];

        $licfile =~ s#/cc/cm_admin_ch$chid#/home#;

        #2. check if the daemon/lmgrd is already running or not
        my $status = "";
        if ($server =~ /ut/) {
          $status = `ssh $server "/usr/ucb/ps -auxwww | grep $licfile | grep -v root"`;
        } else {
          $status = `ssh $server "ps -auxwww | grep $licfile | grep -v root"`;
        }
     
        #3. kill them if already there
        my ($pid, $lmgrd, $liclogfile);
        if ($status ne "") {
           foreach my $l (split(/\n/, $status)) {
              my $pid   = (split(/\s+/, $l))[1]; 
              my $s     = `ssh $server "kill -9 $pid 2>&1 /dev/null"`;
              writeLog($log, $debug, $verbose, "blue", "killing license server/daemon pid $pid");
           }
        }
       
        #4. start license server
        my $cmd = "/apps/FLEXlm/scripts/start_lic $licfile";
	system(qq(ssh $server "su - $owner -c '$cmd' 2>&1 /dev/null">/dev/null &));

	# write to the log file.
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", "Start license $licfile");


	# write to the log file.
	$logbuf = "Returning from do_licmanage().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# return the status.
	return($valid);
}

# function to do a touch on a file or directory.
sub do_touch {
	my $path = shift;
	my $retVal = 1;
	my $valid = 1;

	# write to the log file.
	$logbuf = "In function do_touch().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	if(-e $path) {

		# write to the log file.
		$logbuf = "\"" . $path . "\" exists.";
		$log = 1;
		writeLog($log, $debug, $verbose, "blue", $logbuf);

		$cmd = sprintf("touch %s", $path);

		# write to the log file.
		$logbuf = "Executing \"" . $cmd . "\".";
		$log = 1;
		writeLog($log, $debug, $verbose, "blue", $logbuf);

		# test mode = true
		if($test == 1) {
			$retVal = system($cmd);
			if($retVal == 0) {
				$valid = 0;
			} else {
				$valid = 1;
			}
		}

		# test mode = true
		if($test == 0) {
			printf(LOGFILE "*******************************************************************************\n");
			printf(LOGFILE "***TESTINFO: \"touch $path\"\n\n");
			printf(LOGFILE "*******************************************************************************\n");
			$valid = 0;
		}
	} else {

		# write to the log file.
		$logbuf = "ERROR !!! \"" . $path . "\" does not exist.";
		$log = 1;
		writeLog($log, $debug, $verbose, "red", $logbuf);
	}

	# write to the log file.
	$logbuf = "Returning from do_touch().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# return the status.
	return($valid);
}

# function to perform the chown operation.
sub do_chmod { 
	my $path = shift;
	my $recursive = shift;
	my $permissions = shift;
	my $retVal = 1;
	my $valid = 1;

	# write to the log file.
	$logbuf = "In function do_chmod().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);
	if($recursive == 0) {
		$cmd = sprintf("find %s -mount ! -type l -exec chmod %s {} \\;", $path, $permissions);

		# test mode = true
		if($test == 1) {
			$retVal = system($cmd);
			if($retVal == 0) {
				$valid = 0;
			} else {
				$valid = 1;
			}
		}

		# test mode = true
		if($test == 0) {
			printf(LOGFILE "*******************************************************************************\n");
			printf(LOGFILE "***TESTINFO: \"find %s -mount ! -type l -exec chmod %s {} \\;\n\n", $path, $permissions);
			printf(LOGFILE "*******************************************************************************\n");
			$valid = 0;
		} else {

			# write to the log file.
			$logbuf = "Executing \"" . $cmd . "\".";
			$log = 1;
			writeLog($log, $debug, $verbose, "blue", $logbuf);
		}
	} else {
		$cmd = sprintf("chmod %s %s", $permissions, $path);

		# test mode = true
		if($test == 1) {
			$retVal = system($cmd);
			if($retVal == 0) {
				$valid = 0;
			} else {
				$valid = 1;
			}
		}

		# test mode = true
		if($test == 0) {
			printf(LOGFILE "*******************************************************************************\n");
			printf(LOGFILE "***TESTINFO: \"chmod $permissions $path\"\n\n");
			printf(LOGFILE "*******************************************************************************\n");
			$valid = 0;
		} else {

			# write to the log file.
			$logbuf = "Executing \"" . $cmd . "\".";
			$log = 1;
			writeLog($log, $debug, $verbose, "blue", $logbuf);
		}
	}

	# write to the log file.
	$logbuf = "Returning from do_chmod().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# return the status.
	return($valid);
}

# function to perform the chown operation.
# recursive => find files and exec chown.
# non-recursive => chown file or dir.
sub do_chown {
	my $path = shift;
	my $recursive = shift;
	my $user = shift;
	my $cmd; 
	my $valid = 1;
	my $retVal = 1;

	# write to the log file.
	$logbuf = "In function do_chown().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# recursive
	if($recursive == 0) {
		$cmd = sprintf("find %s -mount ! -type l -exec chown %s {} \\;", $path, $user);

		# test mode = true NO !!!
		# execute the command.
		# successful => valid = 0.
		# unsuccessful => valid = 1.
		if($test == 1) {
			$retVal = system($cmd);
			if($retVal == 0) {
				$valid = 0;
			} else {
				$valid = 1;
			}
		}

		# test mode = true
		# print to the log file the command we would've executed.
		if($test == 0) {
			printf(LOGFILE "*******************************************************************************\n");
			printf(LOGFILE "***TESTINFO: \"find %s -mount ! -type l -exec chown %s {} \\;\n\n", $path, $user);
			printf(LOGFILE "*******************************************************************************\n");
			$valid = 0;
		} else {

			# write to the log file.
			$logbuf = "Executing \"" . $cmd . "\".";
			$log = 1;
			writeLog($log, $debug, $verbose, "blue", $logbuf);
		}
	} else {

		# non recursive.
		$cmd = sprintf("chown %s %s", $user, $path);

		# test mode = true NO !!!
		# execute the command.
		# successful => valid = 0.
		# unsuccessful => valid = 1.
		if($test == 1) {
			$retVal = system($cmd);
			if($retVal == 0) {
				$valid = 0;
			} else {
				$valid = 1;
			}
		}

		# test mode = true
		# print to the log file the command we would've executed.
		if($test == 0) {
			printf(LOGFILE "*******************************************************************************\n");
			printf(LOGFILE "***TESTINFO: \"chown $user $path\"\n\n");
			printf(LOGFILE "*******************************************************************************\n");
			$valid = 0;
		} else {

			# write to the log file.
			$logbuf = "Executing \"" . $cmd . "\".";
			$log = 1;
			writeLog($log, $debug, $verbose, "blue", $logbuf);
		}
	}

	# write to the log file.
	$logbuf = "Returning from do_chown().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# return the status.
	return($valid);
}

# function to perform the *chgrp* operation.
# if recursive option then do a find and exec.
# if non-recursive, then do chgrp.
sub do_chgrp {
	my $path = shift;
	my $recursive = shift;
	my $group = shift;
	my $cmd; 
	my $retVal = 1;
	my $valid = 1;

	# write to the log file.
	$logbuf = "In function do_chgrp().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# recursive = true.
	# find files and do an exec.
	if($recursive == 0) {
		$cmd = sprintf("find %s -mount ! -type l -exec chgrp %s {} \\;", $path, $group);

		# test mode = true NO !!!
		#	execute the command.
		# successfule => valid = 0.
		# unsuccessful => valid = 1.
		if($test == 1) {
			$retVal = system($cmd);
			if($retVal == 0) {
				$valid = 0;
			} else {
				$valid = 1;
			}
		}

		# test mode = true
		# print to the log file the command that we would've executed.
		# set valid = 0.
		if($test == 0) {
			printf(LOGFILE "*******************************************************************************\n");
			printf(LOGFILE "***TESTINFO: \"find %s -mount ! -type l -exec chgrp %s {} \\;\n\n", $path, $group);
			printf(LOGFILE "*******************************************************************************\n");
			$valid = 0;
		}

		# write to the log file.
		$logbuf = "Executing \"" . $cmd . "\".";
		$log = 1;
		writeLog($log, $debug, $verbose, "blue", $logbuf);
	} else {

		# non-recursive.
		# do a chgrp on the path.
		$cmd = sprintf("chgrp %s %s", $group, $path);

		# test mode = true NO !!!		
		# execute the command.
		# successful => valid = 0.
		# unsuccessful => valid = 1.
		if($test == 1) {
			$retVal = system($cmd);
			if($retVal == 0) {
				$valid = 0;
			} else {
				$valid = 1;
			}
		}

		# test mode = true	
		# print to log file the command we would'veexecuted.
		# set valid = 0.
		if($test == 0) {
			printf(LOGFILE "*******************************************************************************\n");
			printf(LOGFILE "***TESTINFO: \"chgrp $group %path\"\n\n");
			printf(LOGFILE "*******************************************************************************\n");
			$valid = 0;
		} else {

			# write to the log file.
			$logbuf = "Executing \"" . $cmd . "\".";
			$log = 1;
			writeLog($log, $debug, $verbose, "blue", $logbuf);
		}
	}

	# write to the log file.
	$logbuf = "Returning from do_chgrp().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# return the status.
	return($valid);
}

# function to find files owned by user-a and chown them to user-b
sub do_find_and_chown {
	my $path = shift;
	my $target = shift;
	my $source = shift;
	my $result;
	my @files;
	my $retVal = 1;
	my $valid = 1;

	# write to the log file.
	$logbuf = "In function do_find_and_chown().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# the command to find and exec chown.
	my $cmd = sprintf("find %s -mount ! -type l -user %s -exec chown %s {} \\;", $path, $source, $target);

	# test mode = true	NO !!!
	# execute the command.
	# successful => valid = 0.
	# unsuccessful => valid = 1.
	if($test == 1) {
		$retVal = system($cmd);
		if($retVal == 0) {
			$valid = 0;
		} else {
			$valid = 1;
		}
	}

	# test mode = true
	# print to log file the command we would've executed.
	if($test == 0) {
		printf(LOGFILE "*******************************************************************************\n");
		printf(LOGINFO "***TESTINFO: \"find $path -follow -mount -user $source -exec chown $target {}\"\n\n");
		printf(LOGFILE "*******************************************************************************\n");
		$valid = 0;
	} else {

		# write to the log file.
		$logbuf = "Executing \"" . $cmd . "\".";
		$log = 1;
		writeLog($log, $debug, $verbose, "blue", $logbuf);
	}

	# write to the log file.
	$logbuf = "Returning from do_find_and_chown().";
	$log = 1;
	writeLog($log, $debug, $verbose, "blue", $logbuf);

	# return the status.
	return($valid);
}

# function to take a lock on the pid file.
sub take_lock {

  sysopen my $fh, $PIDFILE, O_RDWR | O_CREAT or die "$0: open $PIDFILE: $!";
  flock $fh => LOCK_EX                       or die "$0: flock $PIDFILE: $!";

  my $pid = <$fh>;
  if (defined $pid) {
    chomp $pid;
    if (kill 0 => $pid) {
      close $fh;
      exit 1;
    }
  }
  else {
    die "$0: readline $PIDFILE: $!" if $!;
  }

  sysseek  $fh, 0, SEEK_SET or die "$0: sysseek $PIDFILE: $!";
  truncate $fh, 0           or die "$0: truncate $PIDFILE: $!";
  print    $fh "$$\n"       or die "$0: print $PIDFILE: $!";
  close    $fh              or die "$0: close: $!";
}

# # # #

__END__

